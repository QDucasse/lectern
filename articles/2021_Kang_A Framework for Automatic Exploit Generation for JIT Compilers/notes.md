<!-- Please prefix the notes with the date as in [22/12/2020] -->

**Overview:** authors present a framework for **automatic exploit generation** for JIT compilers. It consists of two components: (1) an **analyzer of existing exploits** to extract exploitation primitives, which are abstractions of low-level behaviors useful for constructing exploits and (2) a **primitive composer** to construct an exploit for a new bug given a proof-of-concept input that triggers the bug.

**Analyzer:** the analyzer determines **exploitation primitives**, high-level abstractions of lower-level behaviors represented in terms of one sequence of operations. Four kinds of primitives are extracted:

| Primitive Name | Arguments        | Ability              | Description                                                  |
| -------------- | ---------------- | -------------------- | ------------------------------------------------------------ |
| Read           | `addr`           | `addrs`              | reads the value at address `addr` and its ability is described by the addresses `addrs` it can read from |
| Write          | `addr`, `val`    | `addrs`              | writes an attacker-controlled value `val` to an attacker-control address `addr`, its ability is described by the `addrs` it can write to |
| IP Hijack      | `addr`           | `n`                  | overwrites the instruction pointer register with an attacker-controlled address `addr`, its ability describes the number `n` of lowest bytes it is able to control (*i.e.* the range it can reach) |
| Type Confusion | `obj`, `DstType` | `SrcType`, `DstType` | converts the type of an object `obj` into `DstType`, its ability is defined by its capability to convert from an `SrcType` to a `DstType` |

Each of these primitives is represented by a sequence of operations defined by:

| Operation Name | Arguments              | Description                                                  |
| -------------- | ---------------------- | ------------------------------------------------------------ |
| ReadData       | `obj`, `field`         | reads the value of an object at a specific field             |
| WriteData      | `obj`, `field`, `data` | writes attacker-specified data to the attacker-specified field of an attacker-specified object |
| CreateObj      | `specification`        | creates an object that is the same as the given specification |

An **exploitation plan**, a mixture of real code and descriptions of wanted primitives. Descriptions correspond to the ones described by exploitation primitives where the address is represented by `(base, index, offset)`. An **exploit** derives from **exploitation primitives** and **exploit plans**.

**Preprocessing:** The preprocessing phase relies on inspecting the data flow between different objects. It uses an instruction-level execution trace for a given exploit and **extracts operation sequences** on objects in a **dedicated algorithm**. Then, extracted operation sequences are stored in a **primitive database** as `(sequence, usage, ability)`. They are then sorted by ability for each category.

**Exploit Creation:** A **memory analyzer** keeps track of values, permissions and objects (location and fields) in memory. A **bug analyzer** randomly modifies a PoC file to collect its optimization action sequence and extract the longest common subsequence that keeps optimizations unchanged and therefore leave a potential bug in place. Both these analyzers output their results to the **primitive application** where the primitive is built. It uses an algorithm that takes a sequence from the database, tries to implement each operation in the sequence. It checks pre- and post-conditions for each primitive.

Still a prototype! (only preprocessing phase available)

##### tags: jit, security, unread