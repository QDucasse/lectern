<!-- Please prefix the notes with the date as in [22/12/2020] -->

[20/05/2021]

Oxymoron aims to provide fine-grained memory randomization. It features ***memory-layout-agnostic code*** which works on a per-process level and does not interfere with code sharing. This way, the memory is secure without having to throw away shared libraries.

While ASLR has become widespread, it has also been shown to be ineffective by using large chunks of memory. Using finer grain randomization techniques aim at randomizing functions, basic blocks or even instructions. To be effective, it has to prevent an attacker from using information about the memory layout of one process to infer the layout of another process. This is a particular threat when looking at shared code originating from shared libraries. Most fine-grained techniques also randomize shared libraries for every single process. As a result, there is no identical in any two processes which makes sharing impossible and increases the overall memory footprint.

Oxymoron uses a new x86 calling convention: ***Position-and-Layout-Agnostic Code (PALACE)***. This code uses no instructions that reference other code or data directly. It cuts program code into the smallest sharable piece, a memory page. Those pages are randomized and shared among processes. An index is given to each process and it would appear different to each of them, organized in a translation table.

**Oxymoron Design:** The main objective of Oxymoron is to benefit from both worlds (code sharing AND fine-grained randomization). Four challenges come along this objective: (1) ***small translation table*** ; (2) ***efficient layer of indirection*** ; (3) ***translation inaccessible for adversaries*** ; (4) ***ability to run on a commodity Linux***. The overall procedure consists of:

- **Code Transformation:** The executable *E* is transformed to a PALACE-code executable *Pe*. The same applies to shared libraries, which can be treated like executables. To enable layout-agnostic code, all references to code and data are replaced with a unique label, an assigned index into a translation table. This ***randomization-agnostic translation table (rattle)*** in turn refers to the actual target.
- **Splitting:** The code is split into the smallest possible piece that can be shared: a memory page. The code of *Pe* now consists of code pieces: *p1 | p2 | ... | pn*. The PALACE code is split into page-sized pieces, as those pieces are shuffled, it must be assured that the original semantics of the program are kept intact. Explicit control flow needs to be inserted between consecutive code pieces that might be moved away in a alter stage of randomization. These links are inserted as the last instruction of a piece to ensure the successor is correct.
- **Randomization:** At program load time, the pieces are shuffled by the ASLR part of the OS loader. In memory, their order is completely random and the pieces may have empty gaps of arbitrary size between them. Modern OSes already support ASLR, loading code, data and stack segments at random base addresses. Every memory page is put in its own loadable segment of the executable file or of the shared library. Each process can have its own permutation of the randomization. Only the ***rattle*** needs to be kept up to date with a per-process randomization.

**RATTLE:** This translation table is needed because other methods have drawbacks. Storing the rattle at a **fixed** address in memory allows for its address to be hard-coded in the instructions themselves. Unfortunately, this can be exploited by an attacker. Ut can use a **Global Offset Table (GOT)** but this is realized using relative addresses and forfeits sharing. A dynamic address that is randomly chosen for every process could be stored in a dedicated **machine register**. However, this sacrifices the usage of that register. Rattle chose to use the x86 feature of ***memory segmentation*** to address and at the same time hide it from adversaries. It allows for different *segment descriptors* to be created, each with their own *base address* and *limit* (start and length).

##### tags: aslr, diversification, defense, security