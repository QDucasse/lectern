<!-- Please prefix the notes with the date as in [22/12/2020] -->

[20/05/2021]

The main idea to mitigate ROP attacks is to create an ***Execute-no-Read*** policy to enforce a memory page to be executable-only. However, in contemporary Intel x86 processors, memory pages must always be readable in order to be executable. the same applies to ATM since they only feature one read/write bit, an execute never bit and one bit to distinguish between user and kernel mode. The authors propose to add the XnR primitive as a kernel-level modification.

An attacker needs to read gadgets in memory to be able to perform an attack. While ASLR makes it harder to use the most out of the contents of memory, it can be bypassed by learning a single valid address since they are randomized in group and therefore disclosed altogether. The goal of XnR is to prevent the step of dynamically gathering gadgets which is a necessary precondition in the context of fine-grained ASLR, as the gadgets and their positions are not known to the attacker. since contemporary processors all feature a ***von-Neumann memory architecture that mixes code and data***, the determination whether a particular piece of memory contains code is challenging. Moreover, non-readable but executable memory does not exist.

The application of XnR was emulated in software. Memory accesses between legitimate access to data and read attempts to code have to be distinguished. The ***Memory Management Unit (MMU)*** present in all modern processors introduced the notion of a ***process***, which is a complete address space that exists from each process' point of view. Such address space can have memory regions marked as writable and others as read-only. While the MMU can detect write attempts to any part of a process' memory, detecting read attempts is not supported. They can only be detected by declaring a certain memory region to be *non-present* in the MMU. However a *non-present* memory region cannot be executed anymore. The authors propose to make use of the ***page fault handler***. Every time the MMU detects a memory access violation in a process, it is called. An access violation occurs when a process tried to read memory that is marked as *non-present* or write memory marked as *read-only*. The granularity at which memory regions can have *writable* and *present* attributes is defined by the hardware as so-called memory pages. The page fault handler is heavily solicited as ***demand paging*** starts every process with an empty address space and only maps pages that are actually accessed. Each page fault is provided with additional information (address?, during instruction fetch?). This is important because if the CPU was trying to execute an instruction in a memory page that was *non-present*, it constitutes a legitimate operation and the usual demand paging can occur. On the other hand, if the access **did not** occur during an instruction fetch, the processor was trying to read memory as data. In this case, XnR has to distinguish if the violating address is indeed inside a valid region of data (correct) or points to code (incorrect). Distinguishing the two regions in a process is achieved by interpreting the executable file formats, which provide information as to which region is executable (code) and which is readable (data). To keep up regarding performance, a ***sliding window*** is introduced, it keeps the last recently used *n* pages *present* and all the others as *non-present*.

Implementation in a software-based prototype for Linux and Windows. They share the same idea of using the hardware fault pages but differ in terms of how to instrument the code (open- and closed-source). The three types of memory access that need to be distinguished are: (1) **Instruction Fetch** when the processor fetches a byte from memory to decode and execute the instruction that it represents, this takes place during code execution ; (2) **Load/Store of Data** when an instruction accesses memory that either contains code or data, if it targets data it is a legal operation ; (3) **Load from Code** that constitutes a programmatic disassembly that is considered **illegal**.

![](/home/quentin/Desktop/Research/VM/articles/2014_Backes_You can Run But You Cant Read Preventing Disclosure Exploits in Vulnerable Code/XnR.png)
