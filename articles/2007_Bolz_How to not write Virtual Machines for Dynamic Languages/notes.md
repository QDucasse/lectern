<!-- Please prefix the notes with the date as in [22/12/2020] -->

[30/11/2021]

Dynamic languages are traditionally implemented by writing a virtual machine (VM ) for them in a low-level language like C or in a language that can relatively easily be turned into C. The VM implements an object model supporting the high-level dynamic language's object. It provides features such as automatic garbage collection. The effort required to build a new VM is important and especially for complicated languages in evolution. **Writing a new VM from C** means having to deal with garbage collection and threading which are complicated topics on their own. Implementing a VM on top of a general-purpose object-oriented virtual machine (OOVM) such as the **JVM** or the **CLR**. However, as a language gains in popularity, it will be wanted by the community for it to run on C-level environments as well as on top on high-level VMs. The crux of the argument is that **VMs for dynamic languages should not be written by hand**. The authors argue that it is possible to benefit from OOVMs while keeping the dynamic language implemented as a single simple source code base. The idea is to write an **interpreter for that language in another sufficiently high-level but less dynamic language**. It will play the role of a **specification** for the dynamic language.

**Implementing a language on top of OOVMs** has several advantages such as *better interoperability*, *better performance*, *ease of implementation* or *cross-platform portability*. However, all these points are debatable due to some elements (GC or JIT) that need to be tuned depending on the language/architecture or the fact that the enforced IR might not be the best representation. However, there will definitely be better tools and better GCs.

The main idea PyPy defends is that VMs for dynamic languages should be generated automatically around an interpreter playing the role of a high-level description of a language. PyPy uses a very expressive *object language* **RPython** as the language in which the complete python  interpreter is written with its built-in types. A very expressive metalanguage (Python itself) is used to perform the analysis of RPython code (control and data flow, type inference, etc.). This **translation framework** adds aspects and specializes the interpreter to fit a selectable virtual or hardware runtime environment. 

The benefits are: *single source to maintain*, *writing the interpreter is easier*, *separation of concerns*. And the effort of writing a translation toolchain is still lower than writing the VM from scratch. It is also possible to add a dynamic compilation (JIT) pass in the toolchain so that a dynamic compiler can be automatically generated.


##### tags: general vm, pypy, python, rpython