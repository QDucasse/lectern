### Attack Summary

***Code cache injection*** is able to bypass existing protections. ***Race conditions*** can be exploited to bypass the W+X enforcement. Especially in an environment where multi-threading is available such as web browsers.

### Attacker Threat Model

Defense mechanisms are already deployed on the system such as ***ASLR***, ***constant splitting***, ***random `nop` insertion***, ***guard pages***, ***underlying NX support***. The system can also support ***fine-grained randomization*** and ***control flow hijacking mitigation***. There is also at least one vulnerability that allows attackers to write to an attacker-specified address with attacker-provided contents.

### Recipe

The attacker needs to ***overwrite the code cache*** (that has `WRX` permissions). To do so, the attacker needs to ***bypass ASLR*** and this can be done with the knowledge of a single information disclosure vulnerability.

Memory pages are executable but not writable when allocated by default. The write permission is granted when *new code is installed* (native code is generated and copied to the location), *existing code is patched* (address or constant modifications), *runtime inline caching* (object type or properties cached) or *runtime garbage collection* (memory needs to be managed).

The attacker therefore needs to:

- ***Create a worker:*** create a worker thread.
- ***Initialize the worker***: initialize its environment, makes sure the code cache is created.
- ***Locate the worker's code cache:*** exploit an information disclosure vulnerability to locate the code cache.
- ***Make the Code Cache writable:*** when receiving the main thread's message, the worker thread begins to execute another piece of code, forcing the ***SDT (Software Dynamic Translator in charge of translating the IR to Machine Code)*** to update its code cache. It can simply execute a function that is large enough to force the SDT to create a new chunk.
- ***Monitor and Overwrite the code cache:*** the main thread tries to overwrite it once its status goes to writable.
- ***Execute the shellcode:*** when receiving the main thread's new message, the new worker calls the function whose content has already been overwritten. This way, the injected shellcode is executed.

The race condition needs to be validated and the method that notifies the update takes 23 microsec against the 43 needed by the W+X protection.

---

### Defense Summary

***Dynamic Code Generation Architecture*** that relocates the dynamic code generator to a new process in which the code cache is writable. In the original process where the code executes, it remains read-only. The code cache is synchronized through shared memory and handled transparently through ***remote procedure calls***. 

***Permission Enforcement*** comes by intercepting system calls related to virtual memory management. Specifically, some policies are enforced: (i) memory cannot be mapped as both writable and executable, (ii) when mapping a memory region as executable, the base address and the size must come from the SDT process, and the memory is always mapped as RX, (iii) The permission of non-writable memory cannot be changed.

![](/home/quentin/Desktop/Research/VM/Articles/2015_Song_Exploiting and Protecting Dynamic Code Generation/SDCG.png)
