<!-- Please prefix the notes with the date as in [22/12/2020] -->

Due to the lack of a **stack-based return instruction** and **strict instruction alignment**, it is significantly harder to perform ROP attacks on RISC-V or ARM64. Existing tools to automate ROP attacks utilize implementations based on the **Galileo algorithm**. It searches for byte sequences reassembling a return instruction and analyzes the preceding bytes got valid and useful instructions. Some hidden instructions (overlapping, compressed) can still be missed by the algorithm. Several novelties with the architectures make it significantly harder to find ROP gadgets: (1) the program counter (`pc`) is **not a general purpose register**, (2) there is **no stack-based return instruction**, (3) arguments to function are passed via **dedicated registers instead of the stack**, (4) **memory alignment requirements** prevent execution of unintended sequences, and (5) function epilogue sequences introduce side effects by executing several instructions between loading a return address from the stack and actually using it. 

|                                        | x86   | x86_64 | ARM32 | RISC-V | ARM64 |
| -------------------------------------- | ----- | ------ | ----- | ------ | ----- |
| (1) Writable PC                        | **X** | **X**  | **O** | **X**  | **X** |
| (2) Available stack return instruction | **O** | **O**  | **O** | **X**  | **X** |
| (3) Maximum arguments in registers     | 0     | 4-6    | 4     | 8      | 8     |
| (3) Mixed-purpose registers            | **O** | **O**  | **O** | **X**  | **X** |
| (4) Instruction alignment              | 1     | 1      | 4/2   | 4/2    | 4     |
| (5) Short function epilogue            | **O** | **O**  | **O** | **X**  | **X** |

**Challenges:** ***(1: stack-based returns)*** RISC architectures use a dedicated register to store the return address (`ra/lr`), but fr non-leaf functions (nested calls), the return addresses are still stored on the stack. On RISC-V and ARM64, the program counter is protected and can only be modified by jump instructions. RISC-V use a load instruction (`ld ra, 0x10(sp)`) to restore `ra` at the beginning of the epilogue and ARM64 use load pair to restore `lr` and `fp` in the same instruction before jumping/returning to the caller (`ldp fp, lr, [sp], #0x30; ret`).  Between the loading of the return address from the stack and the actual jump to the intended gadget, callee-saved registers are restored (`s0-s11` on RISC-V). ***(2: memory alignment)*** RISC-V should be aligned to 4 bytes (or 2 for compressed instructions), few hidden instructions are available, ARM64 is 4-bytes aligned only which prevents it. ***(3: function calls)*** arguments have to be loaded in dedicated registers that are not set by function epilogue. ***(4: system calls)*** the system call instruction is very unlikely to be included unintentionally and simply does not exist in applications that use the `libc` as a system-call wrapper.

**RiscyROP:** the gadget finding tool operates through 4 steps to construct a ROP chain to perform arbitrary function calls: (1) **scan** of every aligned address (2) **evaluation** of gadgets using **symbolic execution** and storage in a **database with their constraints** (preconditions and effects) (3) stitching of compatible gadgets and verification that they do not contain breaking side effects (4) **exploit generation** using attacker-supplied argument values.

**Gadget finding:** Does not rely on Galileo and specific byte sequence/pattern but uses **symbolic execution** without known instruction patterns. It allows the tool to discover gadgets based on their effects rather than specific instructions, allowing the use of different types of jumps. Every aligned address is analyzed independently by: (1) symbolically **initializing** registers and stack (2) **executing** the instructions until the control-flow changes to a symbolically unconstrained target (return or jump to an unset reg) and (3) **analyzing** the reached state and **summarizing** the effects of the gadget. The **effects** are summarized determining which registers: are overwritten with data from the stack, depend on one different register, are set to a constant, are changed in more complex ways. **Preconditions** are the return type of the gadget and the path constraints.

**Gadget chaining:** Using attacker-supplied target registers (argument registers for example) as input and aiming for a chain to control them all, the tool provide a gadget chain. Gadgets are processed using priorities - (1) gadgets that load a value from the *stack* over another *register* (2) gadgets that return to a *stack-read* address over *register-based* return (3) gadgets that use the least amount of registers to reduce complexity. Once it is selected, the target registers are updated for the next iteration to include remaining registers and new dependencies. This procedure is done recursively until no registers remain.

 ##### tags: attack, risc-v, rop, security, unread

