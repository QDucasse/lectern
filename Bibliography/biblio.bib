@comment{% Encoding: UTF-8}

@comment{jabref-meta: databaseType:bibtex;}

@comment{jabref-meta: grouping:
0 AllEntriesGroup:;
1 StaticGroup:VM\;0\;1\;0x8066ccff\;\;\;;
1 StaticGroup:Security\;0\;1\;0xe6e64dff\;\;\;;
1 StaticGroup:Quantization\;0\;1\;0xe6b34dff\;\;\;;
1 StaticGroup:Verification\;0\;1\;0xcc8099ff\;\;\;;
1 StaticGroup:Hardware\;0\;1\;0x8099ffff\;\;\;;
1 StaticGroup:Read\;0\;1\;0x00ff00ff\;\;\;;
1 StaticGroup:Testing\;0\;1\;0x994d66ff\;\;\;;
}

@inproceedings{Agache2020,
 author = {Alexandru Agache and Marc Brooker and Alexandra Iordache and Anthony Liguori and Rolf Neugebauer and Phil Piwonka and Diana{-}Maria Popa},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/nsdi/AgacheBILNPP20.bib},
 booktitle = {17th {USENIX} Symposium on Networked Systems Design and Implementation, {NSDI} 2020, Santa Clara, CA, USA, February 25-27, 2020},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 editor = {Ranjita Bhagwan and George Porter},
 pages = {419--434},
 publisher = {{USENIX} Association},
 title = {Firecracker: Lightweight Virtualization for Serverless Applications},
 url = {https://www.usenix.org/conference/nsdi20/presentation/agache},
 year = {2020}
}

@article{Agesen1997,
 author = {Ole Agesen},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1002/(sici)1096-9942(1997)3:2<127::aid-tapo4>3.0.co;2-s},
 groups = {VM},
 issn = {1074-3227},
 journal = {THEORY AND PRACTICE OF OBJECT SYSTEMS},
 pages = {127-155},
 title = {Design and implementation of Pep, a Java Just-In-Time translator},
 volume = {3},
 year = {1997}
}

@article{Agesen2010,
 author = {Ole Agesen and Alex Garthwaite and Jeffrey Sheldon and Pratap Subrahmanyam},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1899928.1899930},
 groups = {VM},
 issn = {0163-5980},
 journal = {SIGOPS Oper. Syst. Rev.},
 pages = {3-18},
 title = {The evolution of an x86 virtual machine monitor},
 volume = {44},
 year = {2010}
}

@misc{Antero1998,
 author = {Taivalsaari Antero and Taivalsaari Antero},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1.1.23.6391},
 groups = {VM},
 journal = {SUN MICROSYSTEMS LABORATORIES SUN MICROSYSTEMS INC. 901 SAN ANTONIO ROAD PALO ALTO CA 94303},
 title = {Implementing a Java Virtual Machine in the Java Programming Language},
 year = {1998}
}

@article{Arnold2000,
 author = {Matthew Arnold and Stephen Fink and David Grove and Michael Hind and Peter F. Sweeney},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/353171.353175},
 groups = {VM},
 journal = {OOPSLA},
 title = {Adaptive optimization in the Jalapeno JVM},
 year = {2000}
}

@article{Bacon1996,
 author = {David F. Bacon and Peter F. Sweeney},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/236338.236371},
 groups = {VM},
 issn = {0362-1340},
 journal = {OOPSLA},
 pages = {324-341},
 title = {Fast static analysis of C++ virtual function calls},
 volume = {31},
 year = {1996}
}

@article{Bala2000,
 address = {New York, NY, USA},
 author = {Bala, Vasanth and Duesterwald, Evelyn and Banerjia, Sanjeev},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/358438.349303},
 issn = {0362-1340},
 issue_date = {May 2000},
 month = {may},
 number = {5},
 numpages = {12},
 pages = {1â€“12},
 publisher = {Association for Computing Machinery},
 title = {Dynamo: A Transparent Dynamic Optimization System},
 url = {https://doi.org/10.1145/358438.349303},
 volume = {35},
 year = {2000}
}

@misc{Barbu2012,
 author = {Guillaume Barbu and Philippe Hoogvorst and Guillaume Duc},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1007/978-3-642-28166-2_1},
 issn = {0302-9743},
 pages = {1-13},
 title = {Application-Replay Attack on Java Cards: When the Garbage Collector Gets Confused},
 year = {2012}
}

@article{Bell1973,
 author = {James R. Bell},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/362248.362270},
 groups = {VM},
 issn = {0001-0782},
 journal = {ACM},
 pages = {370-372},
 title = {Threaded code},
 volume = {16},
 year = {1973}
}

@inproceedings{Blackburn2004,
 author = {Stephen M. Blackburn and Perry Cheng and Kathryn S. McKinley},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/icse/BlackburnCM04.bib},
 booktitle = {26th International Conference on Software Engineering {(ICSE} 2004), 23-28 May 2004, Edinburgh, United Kingdom},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

[28/04/2021]

**Memory Management Toolkit (MMTk)** is written in and for Java. It addresses th tension between flexibility and performance with a combination of design features: 1) **Java** as a systems language 2) **Design patterns** 3) Clean **interface between the VM and MMTk** 4) Composition of **policies and mechanisms to define collectors**.

MMTk groups regions of memory into spaces and implements garbage collection algorithms with a policy that couples a space with an allocation and collection mechanism. *Whole heap* collectors use one policy for most objects while *generational collectors* use one or more. A *write barrier* remembers pointers into independently collected spaces. For every pointer store, the compiler inserts write-barrier code. At execution time, the write-barrier conditionally records pointers between independently collected spaces.

MMTk implements **allocation and collection mechanisms** (*Bump Pointer, Free-List, Tracing, Reference Counting*) and forms **policies** with the implementations (define *Copy Space MarkSweep Space,* etc.) in order to create collectors (*SemiSpace, MarkSweep, RefCount,* etc.).

MMTk design is based on *flexibility* and *performance* and uses for that:

**1) Java as a systems language:**

 MMTk uses the extension defined by and for Jikes RVM that defines special types for unsafe operations: `VM_Offset` (distance between two addresses), `VM_Word` (value returned by dereferencing an address) and `VM_Address`. These **unboxed types** (operations on them never result in allocation) help use pointer arithmetic, casts as well as memory reads and writes. Compiler **pragmas** are used to control *inlining* and *interruptibility*. Control over inlining helps improve efficiency for system-level code written in an object-oriented style. By executing in its own heap, the collector must not scavenge itself and *pre-copies* any GC-related  instances and 

**2) Design Patterns:**

MMTk uses patterns for efficiency and reuse (*TriColor, RootSet, Adapter, Facade, Iterator* and *Proxy*). They are here used for several reasons:

- **Hot and Cold Paths:** MMTk marks the *hot path* (used frequently and lightweight) with `PragmaInline` and the *cold path* (used rarely and heavyweight) with `PragmaNoInline`. This is the case of a copying nursery (copy pointers *-hot-* then acquire new memory *-cold-*).
- **Local and Global Scopes:** Multi-threaded memory manager performance and correctness depends on a scalable division of local and global context. This is done through the **use of classes in MMTk**, it uses an instance with each thread and uses the class to reflect the global state. Instance methods operate over heir data without syncronization and access shared state through synchronized global class methods. MMTk provides 'local' and 'global' variants of a class,  with N instances of the global class and N x P instances of the local class, each mapped to one global instance. 
- **Prepare and Release Phases:** MMTk uses a high level algorithm to perform the stop-the-world collectors (*prepare, process all work* and *release*). The phase are split in global and local steps: `prepareGlobal`,  `prepareLocal`,  **`processAllWork`** , `releaseLocal` and  `releaseGlobal`. The `processAllWork` is common to all collectors and consists of processing a collection work queue. Each new collector only implements a prepare and release phase.
- **Multiplexed Delegation:** When the memory manager allocates or traces an *object*, it invokes the corresponding method in the *plan*, which then delegates responsibility to the appropriate *policy*. 

**3) Interface VM/MMTk:**  The interface between the VM and the MMis bidirectional and each side contains ***requirements*** and *features*. The key requirements of the MM include *identifying source of pointers*, *providing access to per-object GC  state*, etc.  On the other side, the VM requires that the MM provide allocation, finalization write barrier implementations, soft/weak/phantom references and statistics such as heap size and GC count.

**4) Composition (Mechanisms, Policies, Plans):** Mechanisms are **collector-neutral**, **highly-tuned** mechanisms include *bump-pointer, free list, large object allocations*. Policies implements five policies: *immortal allocation, copying collection, mark-sweep collection, reference counting collection* and *treadmill collection*. MMTk maps policies to spaces which are contiguous regions of virtual memory managed by a single policy. Each policy follows a local/global pattern. A plan is MMTk's highest level of composition, defining the rules by which policies are composed (collection and allocation policy for each object for example).

},
 doi = {10.1109/ICSE.2004.1317436},
 editor = {Anthony Finkelstein and Jacky Estublier and David S. Rosenblum},
 groups = {VM},
 pages = {137--146},
 publisher = {{IEEE} Computer Society},
 title = {Oil and Water? High Performance Garbage Collection in Java with MMTk},
 year = {2004}
}

@article{Bolz2009,
 author = {Carl Friedrich Bolz and Antonio Cuni and Maciej Fijalkowski and Armin Rigo},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1565824.1565827},
 groups = {VM},
 journal = {ICOOOLPS},
 title = {Tracing the meta-level: PyPy's tracing JIT compiler},
 year = {2009}
}

@article{Bolz2011,
 author = {Carl Friedrich Bolz and Antonio Cuni and Maciej FijaÅ‚kowski and Michael Leuschel and Samuele Pedroni and Armin Rigo},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2069172.2069181},
 groups = {VM},
 journal = {ICOOOLPS},
 title = {Runtime feedback in a meta-tracing JIT for efficient dynamic languages},
 year = {2011}
}

@article{Burke1999,
 author = {Michael G. Burke and John Whaley and Jong-Deok Choi and Stephen Fink and David Grove and Michael Hind and Vivek Sarkar and Mauricio J. Serrano and V. C. Sreedhar and Harini Srinivasan},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/304065.304113},
 groups = {VM},
 journal = {JAVA},
 title = {The Jalapeno dynamic optimizing compiler for Java},
 year = {1999}
}

@article{Bush1987,
 author = {William R. Bush and A. Dain Samples and David Ungar and Paul N. Hilfinger},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/36205.36192},
 groups = {VM, Read},
 issn = {0362-1340},
 journal = {ACM},
 keywords = {read},
 pages = {112-116},
 readstatus = {read},
 title = {Compiling Smalltalk-80 to a RISC},
 volume = {22},
 year = {1987}
}

@article{Chambers1989,
 author = {C. Chambers and D. Ungar and E. Lee},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/74877.74884},
 groups = {VM},
 journal = {ACM},
 title = {An efficient implementation of SELF a dynamically-typed object-oriented language based on prototypes},
 year = {1989}
}

@inproceedings{Chambers1989a,
 author = {Craig Chambers and David M. Ungar},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/pldi/ChambersU89.bib},
 booktitle = {Proceedings of the {ACM} SIGPLAN'89 Conference on Programming Language Design and Implementation (PLDI), Portland, Oregon, USA, June 21-23, 1989},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/73141.74831},
 editor = {Richard L. Wexelblat},
 groups = {VM},
 pages = {146--160},
 publisher = {{ACM}},
 title = {Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language},
 year = {1989}
}

@article{Chambers2004,
 author = {Craig Chambers and David Ungar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/989393.989425},
 groups = {VM},
 issn = {0362-1340},
 journal = {SIGPLAN},
 pages = {295-312},
 title = {A Retrospective on "Customization: Optimizing Compiler Technology for Self, a Dynamically-Typed Object-Oriented Programming Language"},
 volume = {39},
 year = {2004}
}

@article{Cheng2001,
 author = {Perry Cheng and Guy E. Blelloch},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/378795.378823},
 groups = {VM},
 journal = {PLDI},
 title = {A parallel, real-time garbage collector},
 year = {2001}
}

@inproceedings{Cho2018,
 author = {Shenghsun Cho and Michael Ferdman and Peter A. Milder},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/fpl/ChoFM18.bib},
 booktitle = {28th International Conference on Field Programmable Logic and Applications, {FPL} 2018, Dublin, Ireland, August 27-31, 2018},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/FPL.2018.00080},
 pages = {435--442},
 publisher = {{IEEE} Computer Society},
 title = {FPGASwarm: High Throughput Model Checking on FPGAs},
 year = {2018}
}

@article{Click1995,
 author = {Cliff Click and Michael Paleczny},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/202529.202534},
 groups = {VM},
 journal = {IR},
 title = {A simple graph-based intermediate representation},
 year = {1995}
}

@article{Click2002,
 author = {Cliff Click and John Rose},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/583810.583821},
 groups = {VM},
 journal = {JGI},
 title = {Fast subtype checking in the HotSpot JVM},
 year = {2002}
}

@article{Click2005,
 author = {Cliff Click and Gil Tene and Michael Wolf},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1064979.1064988},
 groups = {VM},
 journal = {VEE},
 title = {The pauseless GC algorithm},
 year = {2005}
}

@article{Cointe1987,
 author = {Pierre Cointe},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/oopsla/Cointe87.bib},
 booktitle = {Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA'87), Orlando, Florida, USA, October 4-8, 1987, Proceedings},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/38765.38822},
 editor = {Norman K. Meyrowitz},
 pages = {156--167},
 publisher = {{ACM}},
 title = {Metaclasses are First Class: the ObjVlisp Model},
 year = {1987}
}

@article{Dean,
 author = {Jeffrey Dean and David Grove and Craig Chambers},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1007/3-540-49538-x_5},
 groups = {VM},
 journal = {ECOOP},
 pages = {77-101},
 title = {Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis},
 year = {1995}
}

@inproceedings{Dehnert2003,
 author = {James C. Dehnert and Brian Grant and John P. Banning and Richard Johnson and Thomas Kistler and Alexander Klaiber and Jim Mattson},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/cgo/DehnertGBJKKM03.bib},
 booktitle = {1st {IEEE} / {ACM} International Symposium on Code Generation and Optimization {(CGO} 2003), 23-26 March 2003, San Francisco, CA, {USA}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/CGO.2003.1191529},
 editor = {Richard Johnson and Tom Conte and Wen{-}mei W. Hwu},
 groups = {VM},
 pages = {15--24},
 publisher = {{IEEE} Computer Society},
 title = {The Transmeta Code Morphing - Software: Using Speculation, Recovery, and Adaptive Retranslation to Address Real-Life Challenges},
 year = {2003}
}

@article{Deutsch1984,
 author = {L. Peter Deutsch and Allan M. Schiffman},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/800017.800542},
 groups = {VM},
 journal = {ACM},
 title = {Efficient implementation of the smalltalk-80 system},
 year = {1984}
}

@article{Dewar1975,
 author = {Robert B. K. Dewar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/360825.360849},
 groups = {VM},
 issn = {0001-0782},
 journal = {ACM},
 pages = {330-331},
 title = {Indirect threaded code},
 volume = {18},
 year = {1975}
}

@article{Diehl2000,
 author = {Stephan Diehl and Pieter Hartel and Peter Sestoft},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1016/s0167-739x(99)00088-6},
 groups = {VM},
 issn = {0167-739X},
 journal = {FGCS},
 pages = {739-751},
 title = {Abstract machines for programming language implementation},
 volume = {16},
 year = {2000}
}

@inproceedings{Du2019,
 address = {New York, NY, USA},
 author = {Du, Dong and Hua, Zhichao and Xia, Yubin and Zang, Binyu and Chen, Haibo},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/3307650.3322218},
 isbn = {9781450366694},
 keywords = {accelerators, operating system, inter-process communication, microkernel},
 location = {Phoenix, Arizona},
 numpages = {14},
 pages = {671â€“684},
 publisher = {Association for Computing Machinery},
 series = {ISCA '19},
 title = {XPC: Architectural Support for Secure and Efficient Cross Process Call},
 url = {https://doi.org/10.1145/3307650.3322218},
 year = {2019}
}

@article{Duboscq2014,
 author = {Gilles Duboscq and Thomas WÃ¼rthinger and Hanspeter MÃ¶ssenbÃ¶ck},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2647508.2647521},
 groups = {VM},
 journal = {PPPJ},
 title = {Speculation without regret reducing deoptimization meta-data in the Graal compiler},
 year = {2014}
}

@misc{Eckert2013,
 author = {Marcel Eckert and Igor Podebrad and Bernd Klauer},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[15/12/2020]*

Prevention against **Direct Memory Access (DMA)** attacks adding a **watchdog mechanism** that scans the data passing by and interrupts the processor after the detection of a malicious data or instruction sequence.

*REFERENCES TO OTHER ARTICLES IN THE FIELD OF PROCESSOR SECURITY*

[1] Chhabra et al., *An analysis of secure processor architectures*

[2] Wang et al., *Computer Architecture and Security: Fundamentals of Designing Secure Computer Systems*



DMA is a well-known technique to release processors from time consuming workload caused by simple data transfers. **Those transfers are performed without supervision**. Data and instruction are communicated between the memory as sink and source or between the memory and mass storage or interfaces. They reach their destination block-wise without completely before being checked by anti-malware agents. To complete the success of a DMA attack, **the attack pattern needs to launch the code before it has been checked** by the anti-malware agent. Another opportunity is to infect the **anti-malware** software directly.

The introduction of a **DMA-watchdog** can solve the issue. The watchdog resides between the *DMA-Controller* and the *Memory Controller*. It supervises the data part of the memory-bus with a number of sensors that provide a pattern matching functionality to identify malware. If one of the sensors is matching, it signals the watchdog that will, in turn, block the current DMA-transfer. The pattern matching is performed in parallel.

*PRHS (Partially Reconfigurable Heterogeneous System)* framework used to deploy the project on FPGA. 

*DESCRIPTION AND FIGURE*

**Proof-of-concept**: A DMA Simulator is added to the secondary data bus of the system and to the RAM via an SD-Arbiter. Its task is to *copy the content of internal Block-RAM (8KiB) to a given RAM address*. It does not take additional CPU time as it is completely independent.

},
 doi = {10.1007/978-3-642-40779-6_12},
 groups = {Hardware, Security, Read},
 issn = {0302-9743},
 pages = {145-151},
 title = {Hardware Based Security Enhanced Direct Memory Access},
 year = {2013}
}

@phdthesis{Eckert2014,
 address = {Hamburg},
 author = {Michael Marcel Eckert},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 editor = {Bernd Klauer},
 groups = {VM},
 pagetotal = {VI, 152},
 ppn_gvk = {784113750},
 title = {FPGA-based system virtual machines},
 year = {2014}
}

@article{Ehringer2010,
 author = {Ehringer, David},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

[22/04/2021]

Java aims at portability with the **Java Virtual Machine**. It consists of a supposedly stable ecosystem for desktop application through the **JSE platform** and **JEE server**. However the **mobile ecosystem JME** is more fragmented. Google abandonned both the JVM and JME with the **Dalvik virtual machine** along with **limited implementation of standard Java libraries**.

Android runtime must support: **limited processor speed, limited RAM, no swap space, battery powered, sandboxed application runtime, diverse set of devices**. In order to answer those requirements, each Android application runs in its own process with its own Dalvik VM (a register-based VM) that executes a Dalvik Executable file (`.dex`). The Dalvik VM relies on the Linux kernel for threading and low-memory management.

**DEX File Format:** For each class in Java source code, a `.class` file is generated (`javac`) with the corresponding bytecode. The corresponding `.dex` file is generated from those `.class` files (using `dx`). This file format uses specific constant pools for strings, type/class, fields or methods. These pools are shared among all classes. These memory optimizations brings more complexity to the GC because it is independent from applications. Mark bits are separated from other heap memory in order to keep the memory sharing.

**Zygote:** The Zygote enable fast startup time for new instances as well as sharing of code. It assumes a significant number of core libraries are used among multiple applications and often in read-only mode. The Zygote is a VM process that starts at system boot time, preloads core libraries and waits for socket request to fork a new VM.





},
 journal = {Techn. report (March 2010)},
 number = {8},
 title = {The Dalvik Virtual Machine Architecture},
 volume = {4},
 year = {2010}
}

@article{Ertl1995,
 author = {M. Anton Ertl},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[15/12/2020]*

While interpreters are used for their *simplicity* and *portability*, the question of *performance* rises and along it the question of the stack vs register architecture.

The **interpretation of a virtual machine instruction** consists of three parts: (1) **access the arguments** of the instruction, (2) **perform the function** of the instruction and (3) **dispatch (fetch, decode and start) the next instruction**. The *first* and *third* parts constitute the interpreter overhead.

The most efficient method for fetching, decoding and starting the next instruction is **direct threading**: instructions are represented by the *addresses of the routine* that implements them, and *instruction dispatch consists of fetching that address and jumping to the routine*. However, direct threading cannot be implemented in ANSI C but are replaced by either a **giant switch** or **calls**. The overhead induced by the two methods is due to the [range check/table lookup/jump] routine of the *switch method* and the fact that every virtual machine register (instruction and stack pointers) have to be kept in global or static variables for the *call method*. In the *switch method*, the virtual registers can be kept as local variables.

If the instructions are of constant length, the **dispatch of the next instruction can be performed in parallel with the processing of the current instruction**.  In addition, the overhead can also be reduced by **reducing the number of primitives executed**, i.e. by *increasing the semantic content of each instruction*. Combining often-used instruction sequences into one instruction or specializing an instruction for a frequent constant argument are well-known techniques.

While on the hardware side the contest between stack and registers is won by registers, the discussion is different for interpreters. **Data flow analysis** to perform the best register allocation is expensive and the **spill** are much more time consuming than in hardware. Moreover, in hardware the register numbers are decoded in parallel whereas a simple software implementation has to fetch and/or decode the register numbers using separate instructions.

**If there are enough registers, the number of operands fetches and stores can  be reduced by keeping n top-of-the-stack values in registers**.

Mapping a constant number of items in registers is simple but unnecessary. It would be better to keep a *varying number of items in registers*, on an on-demand basis (like a **cache**).

Every allowed mapping of stack items to machine registers constitutes a **cache state**. Many stack pointer updates can be optimized: the cache state can hold the information on how much the contents of the stack pointer vary from the actual value of the stack pointer (this difference can correspond to the number of stack items in the cache). This means the stack pointer does not need to be updated when an instruction can access all stack items in registers.

There should be one state for every number of stack items in registers. The bottom of the cached stack items should be in all states and the other stack items allocated similarly. This avoids the need to move stack items around the bottom of the cache when something on the top changes. 



},
 doi = {10.1145/207110.207165},
 groups = {VM},
 journal = {SIGPLAN},
 title = {Stack caching for interpreters},
 year = {1995}
}

@article{Ertl2002,
 author = {M. Anton Ertl and David Gregg and Andreas Krall and Bernd Paysan},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/journals/spe/ErtlGKP02.bib},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1002/spe.434},
 groups = {VM},
 journal = {Softw. Pract. Exp.},
 number = {3},
 pages = {265--294},
 title = {Vmgen: a generator of efficient virtual machine interpreters},
 volume = {32},
 year = {2002}
}

@article{Ertl2003,
 author = {M. Anton Ertl and David Gregg},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/781131.781162},
 groups = {VM},
 journal = {ACM Transactions on Programming Languages and Systems},
 title = {Optimizing indirect branch prediction accuracy in virtual machine interpreters},
 year = {2003}
}

@article{Ertl2003a,
 author = {M. Anton Ertl and David Gregg},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/journals/jilp/ErtlG03.bib},
 journal = {J. Instr. Level Parallelism},
 title = {The Structure and Performance of Efficient Interpreters},
 url = {http://www.jilp.org/vol5/v5paper12.pdf},
 volume = {5},
 year = {2003}
}

@article{Ertl2004,
 author = {M. Anton Ertl and David Gregg},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1059579.1059583},
 groups = {VM},
 journal = {IVME},
 title = {Combining stack caching with dynamic superinstructions},
 year = {2004}
}

@article{Ertl2005,
 author = {M. Anton Ertl},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1016/j.scico.2005.04.001},
 groups = {VM},
 issn = {0167-6423},
 journal = {SCP},
 pages = {251-252},
 title = {Advances in interpreters, virtual machines and emulators},
 volume = {57},
 year = {2005}
}

@article{Faes,
 author = {P. Faes and M. Christiaens and D. Buytaert and D. Stroobandt},
 comment = {<!-- Please prefix the notes with the date as in "[22/12/2020]:" -->

*[08/12/2020]:*

This paper presents a virtual machine, based on the *Jikes Research Virtual Machine* (Jalapeno), that is able to bridge the gap by providing the same capabilities to hardware components as to software components. This integration is achieved by introducing an **architecture and protocol that allow reconfigurable hardware and software to communicate with each other in a transparent manner *i.e.* no component of the design needs to be aware whether other components are implemented in hardware or in software.** It also allows reconfigurable hardware to manage dynamically allocated memory.

Granting the same capabilities to HW as SW with regard to object references highlights three advantages:

- The number of HW registers can be limited. Instead of passing a large number of parameters, a reference to an object that contains the required data can be provided.
- Neither the HW or SW needs to know in what type of memory the object actually resides. The JVM runtime can implement heuristics that place data closer to the computing unit that is likely to use it in the near future.
- Calling a method, whether it is implemented in SW or HW is completely transparent. This allows a HW method to perform the same operations as a SW method, call methods of any of its arguments or pass them on to other methods.



**Architecture:** The reconfigurable computing device is modeled as a *shared memory machine.* *The address space of the HW is mapped into the address space of the JVM.* This way, the *JVM can access memory and control the registers of the HW* while the *HW can access the JVM's heap through Direct Memory Access.*

**Protocol:** A region is used for *garbage collection* and has a one-to-one mapping to the internal RAM for object references. *Method parameters* and *return values* are mapped arbitrarily onto addresses in the internal RAM for primitive datatypes or the internal RAM itself for object references. The rest of the addresses are *control registers* and are not mapped onto RAM but are either ignored or directly connected to HW registers.

*USE CASE FROM THE PAPER IS A GOOD SUMMARY*

***Garbage-Collector:*** The runtime system collects unused objects in the heap by conducting a liveness check (through an *object-reference graph*) and compacting the resulting memory to create a contiguous region of unused memory. This type of GC is called "stop-the-world". 

The GC in the HW/SW system needs to send a *pause* signal to each HW entity and then *resume* them once finished. This can be done because the GC has access to a list of all available HW entities (note that pausing is required so that no reference is changed, primitive computation can continue). The object references on the HW side can either be in the RAM (that is directly mapped to the garbage collector region) or hidden and fragmented in many different small RAMs or in registers. When a pause is requested, the HW needs to expose those regions by copying them into the GC region. 



***Results:*** Impact of GC is limited to an additional 2.32% execution time 

 

},
 doi = {10.1109/fpl.2005.1515811},
 groups = {VM, Read},
 journal = {IEEE},
 title = {FPGA-aware garbage collection in Java},
 year = {2005}
}

@inproceedings{Fink2003,
 author = {Stephen J. Fink and Feng Qian},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/cgo/FinkQ03.bib},
 booktitle = {1st {IEEE} / {ACM} International Symposium on Code Generation and Optimization {(CGO} 2003), 23-26 March 2003, San Francisco, CA, {USA}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/CGO.2003.1191549},
 editor = {Richard Johnson and Tom Conte and Wen{-}mei W. Hwu},
 groups = {VM},
 pages = {241--252},
 publisher = {{IEEE} Computer Society},
 title = {Design, Implementation and Evaluation of Adaptive Recompilation with On-Stack Replacement},
 year = {2003}
}

@inproceedings{Fournet2013,
 author = {C{\'{e}}dric Fournet and Nikhil Swamy and Juan Chen and Pierre{-}{\'{E}}variste Dagand and Pierre{-}Yves Strub and Benjamin Livshits},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/popl/FournetSCDSL13.bib},
 booktitle = {The 40th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages, {POPL} '13, Rome, Italy - January 23 - 25, 2013},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2429069.2429114},
 editor = {Roberto Giacobazzi and Radhia Cousot},
 pages = {371--384},
 publisher = {{ACM}},
 title = {Fully abstract compilation to JavaScript},
 year = {2013}
}

@article{Fournier2020,
 author = {Emilien Fournier and Ciprian Teodorov and Loic Lagadec},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[08/12/2020]*

Menhir is a modular hardware model-checker. Menhir decouples the verification core from the modeling language semantics by introducing a generic language-agnostic verification interface (**GLI**). Menhir provides a *polymorphic verification core*. It offers a **pure hardware configuration** (VHDL-based GLI-specific modeling language) as well as a **system-on-chip (SoC) configuration** (existing software implementation of the modeling language). Two system specification are handled, **DVE** as well as **EMI** and six verification algorithms.

**Explicit state online model checking for regular safety specifications.**

The verification algorithm is built upon a model. The model is represented as follows:

```pseudocode
structure M (C: Type) :=
	(initial : set C)
	(next    : C -> set C)
	(is_safe : C -> bool)
```

where `M` is the model over an arbitrary configuration `C`. `initial` is the set of the initial configurations, `next` outputs a set of configurations given a specific one and `is_safe` checks that a given configuration is safe. 



The verification algorithm itself is presented as follows:

``` pseudocode
def safety_checker (m: M) : bool :=
	K <- {}
	F <- {}
	N <- m.initial
	do
		if there is n in N such as not(m.is_safe(n)) 
			then return false
		K, F <- KuN, N\K
	while not(F is empty)
	return true
```

where `K` is the known set and `F` the frontier. `K` stores the states encountered while `F` only stores the configurations discovered recently that HAVE NOT yet been processed. The algorithm starts by populating the `N` set with the initial states. The states in the `N` set are checked for safety and the next states are added to `F` and `K`.  If an unsafe configuration is found, the algorithm stops.

*LOOK AT FIGURE 1 FOR ARCHITECTURE OVERVIEW*

Model-checker organized in two parametric layers: ***Model Frontend*** containing *Next State Generator* and *Invariant Checker* and ***Storage Backend*** that contains the *Frontier FIFO* and *Known Set*. Between the two parts is the **GLI** which mediates the dialogue from the *Frontend* to the *Controller*. The *Controller* itself is composed of the *Next Controller* (access to the **GLI**),  the *Scheduler* (forwards the newly discovered configurations) and the *Termination Checker* (monitors the progression). 

The call to `is_safe` is inlined into the `next` instruction to reduce the call cost. 

*LOOK AT FIGURE 2 FOR GLI SPECS*

*LOOK AT FIGURE 3 FOR ALGORITHM POSSIBILITIES*

},
 doi = {10.1109/dsd51259.2020.00022},
 groups = {Verification, Hardware, Read},
 title = {Menhir: Generic High-Speed FPGA Model-Checker},
 year = {2020}
}

@article{Frampton2009,
 author = {Daniel Frampton and Stephen M. Blackburn and Perry Cheng and Robin J. Garner and David Grove and J. Eliot B. Moss and Sergey I. Salishev},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1508293.1508305},
 groups = {VM},
 journal = {VEE},
 title = {Demystifying magic: high-level low-level programming},
 year = {2009}
}

@article{Franz1997,
 author = {Michael Franz and Thomas Kistler},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/265563.265576},
 groups = {VM},
 issn = {0001-0782},
 journal = {Communications of the ACM},
 pages = {87-94},
 title = {Slim binaries},
 volume = {40},
 year = {1997}
}

@article{Freudenberg2014,
 author = {Bert Freudenberg and Dan H. H. Ingalls and Tim Felgentreff and Tobias Pape and Robert Hirschfeld},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2661088.2661100},
 groups = {VM},
 journal = {DLS},
 title = {SqueakJS: a modern and practical smalltalk that runs in any browser},
 year = {2014}
}

@inproceedings{Fuess2008,
 author = {Mary Ellen Fuess and Miriam Leeser and Tim Leonard},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/fccm/FuessLL08.bib},
 booktitle = {16th {IEEE} International Symposium on Field-Programmable Custom Computing Machines, {FCCM} 2008, 14-15 April 2008, Stanford, Palo Alto, California, {USA}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/FCCM.2008.36},
 editor = {Kenneth L. Pocek and Duncan A. Buell},
 pages = {119--126},
 publisher = {{IEEE} Computer Society},
 title = {An {FPGA} Implementation of Explicit-State Model Checking},
 year = {2008}
}

@article{Gal2006,
 author = {Andreas Gal and Christian W. Probst and Michael Franz},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1134760.1134780},
 groups = {VM},
 journal = {VEE},
 title = {HotpathVM: an effective JIT compiler for resource-constrained devices},
 year = {2006}
}

@article{Gosling1995,
 author = {James Gosling},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[06/01/2021]*

Java emerged from its divergences with C++ by using a compiler to generate byte coded machine independent instructions. While this type of method is usually unsuitable for higher-level manipulation, some twists are used: unusual amount of **type information**, **restrictions on the use of the operand stack** and heavy reliance on **symbolic references** and **on-the-fly code rewriting**. 

Instruction definitions follow this inductive property: *Given only the type state before the execution of the instruction, the type state afterwards is determined*.  Smalltalk or PostScript stack-based codes do not have this property. The main idea behind this specification is **simplicity**.

In conjunction, instructions follow the property: *When there are two execution paths into the same point, they must arrive there with exactly the same type state*. This means that bytecode generators cannot write loops that iterate through arrays copying each element on the stack. Since all paths to a point are required to arrive with the same type state, then the type state from any incoming path can be used to do further manipulations.

These restrictions allow a number of important consequences:

- **Static checkability**: The last phase of the bytecode loader is the **verifier**, it traverses the bytecode, constructs type state information and verifies the type parameters of all opcodes. Once the **verifier** finishes, it is guaranteed that: there are no operand stack overflows or underflows, the types of the parameters of opcodes is correct, no illegal data conversions are done and object field accesses are legal. It helps the interpreter and provides a secure environment (no pointer can be forged, access restrictions are enforced, etc.).
- **Fragile Superclasses**: Java uses symbolic references to answer the issue. For example, the `getfield` opcode does not use an offset into the object but rather an index into the symbol table. Once the class is loaded, the offset into the object does not change. When the `getfield` opcode is executed, the interpreter looks up the symbol, finds its offset then rewrites the instruction to be a quick `getfield` with the exact offset.
- **Portability**: Compiled programs are portable given the end device has an interpreter.
- **Translation to machine code**: The static nature of the type states enable simple on-the-fly translation of bytecodes into machine code (no dynamic checks or inferences).



A deterministic stack type-state restriction and a bytecode IR allow the bytecoded program to be compact then directly interpreted or translated to machine code. The implementation of these manipulations can be simple, fast and small.},
 doi = {10.1145/202529.202541},
 groups = {VM},
 journal = {ACM SIGPLAN Workshop onIntermediate Representations},
 subtitle = {ACM SIGPLAN workshop on intermediate representations (IR'95)},
 title = {Java intermediate bytecodes},
 year = {1995}
}

@inproceedings{Govindavajhala2003,
 author = {Sudhakar Govindavajhala and Andrew W. Appel},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/sp/GovindavajhalaA03.bib},
 booktitle = {2003 {IEEE} Symposium on Security and Privacy (S{\&}P 2003), 11-14 May 2003, Berkeley, CA, {USA}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/SECPRI.2003.1199334},
 pages = {154--165},
 publisher = {{IEEE} Computer Society},
 title = {Using Memory Errors to Attack a Virtual Machine},
 year = {2003}
}

@inproceedings{Grimmer2015,
 author = {Matthias Grimmer and Chris Seaton and Thomas W{\"{u}}rthinger and Hanspeter M{\"{o}}ssenb{\"{o}}ck},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/aosd/GrimmerSWM15.bib},
 booktitle = {Proceedings of the 14th International Conference on Modularity, {MODULARITY} 2015, Fort Collins, CO, USA, March 16 - 19, 2015},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2724525.2728790},
 editor = {Robert B. France and Sudipto Ghosh and Gary T. Leavens},
 groups = {VM},
 pages = {1--13},
 publisher = {{ACM}},
 title = {Dynamically composing languages in a modular way: supporting {C} extensions for dynamic languages},
 year = {2015}
}

@article{Gunadi2015,
 abstract = {Android is an operating system that has been used in a majority of mobile devices. Each application in Android runs in an instance of the Dalvik virtual machine, which is a register-based virtual machine (VM). Most applications for Android are developed using Java, compiled to Java bytecode and then translated to DEX bytecode using the dx tool in the Android SDK. In this work, we aim to develop a type-based method for certifying non-interference properties of DEX bytecode, following a methodology that has been developed for Java bytecode certification by Barthe et al. To this end, we develop a formal operational semantics of the Dalvik VM, a type system for DEX bytecode, and prove the soundness of the type system with respect to a notion of non-interference. We then study the translation process from Java bytecode to DEX bytecode, as implemented in the dx tool in the Android SDK. We show that an abstracted version of the translation from Java bytecode to DEX bytecode preserves the non-interference property. More precisely, we show that if the Java bytecode is typable in Barthe et al's type system (which guarantees non-interference) then its translation is typable in our type system. This result opens up the possibility to leverage existing bytecode verifiers for Java to certify non-interference properties of Android bytecode.},
 archiveprefix = {arXiv},
 author = {Hendra Gunadi and Alwen Tiu and Rajeev Gore},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 eprint = {1504.01842},
 file = {:http\://arxiv.org/pdf/1504.01842v5:PDF},
 groups = {VM},
 journal = {arXiv},
 keywords = {cs.PL},
 month = {Apr},
 primaryclass = {cs.PL},
 title = {Formal Certification of Android Bytecode},
 year = {2015}
}

@techreport{Haupt2011,
 address = {Am Neuen Palais 10, 14469 Potsdam},
 author = {Haupt, Michael and Marr, Stefan and Hirschfeld, Robert},
 biburl = {https://www.bibsonomy.org/bibtex/26ce830821a88a512aa679299a493dc8d/gron},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

[27/04/2021]

Application of **MDSOC** (multi-dimensional separation of concerns) and **SPL** (software product line) principles to high-level language virtual machines. Modularisation of **CSOM** using **VMADL** (virtual machine architecture description language). VMs are intricate pieces of software, and modularisation can help dealing with their understanding and overall maintainability. The notion of **service module** helps untangling the complexity of VMs. It consists of a module with *bidirectional interface* that can receive requests and exhibit internal situations to the outside.

CSOM is a SmallTalk Virtual Machine written in C. It does not support images but rather SmallTalk code written in text files. Two threading possibilities are used: the system `pthreads` or threads from within the VM itself. The GC is a mark/sweep collector. a Threaded-interpreter, additional integral representation and snapshots have been developed as extension.

**VMADL**: system architectures need to be supported at source code level and uses **service modules** with signals linking each other called *exposed join points*. It provides a frame in which an **implementation language** and an **aspect language**. Here the implementation language is C and the aspect language is **AspectC++**. In **AspectC++**, the `services` are defined and can use `require` and `expose` to link them between each other. A construct used to implement module interactions is a `combiner`.

An extension of C called ClassDL is used to help with OOP mechanisms. The combination of all the different elements create a toolchain generating a modular VM on demand.},
 day = {18},
 institution = {Hasso Plattner Institute},
 keywords = {AOP Architecture ArchitectureLanguage CSOM MasterThesis MeMyPublication Modularization Productline VirtualMachine aspect-oriented myown services},
 month = {April},
 number = {48},
 pages = {26},
 publisher = {UniversitÃ¤tsverlag Potsdam},
 series = {HPI TR},
 timestamp = {2018-08-26T17:40:07.000+0200},
 title = {CSOM/PL: A Virtual Machine Product Line*},
 url = {http://www.amazon.de/CSOM-PL-virtual-machine-product/dp/3869561343},
 year = {2011}
}

@article{Hoelzle,
 author = {Urs HÃ¶lzle and Craig Chambers and David Ungar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[08/12/2020]:*

Historically, dynamically-typed object-oriented languages have run much slower than statically-typed languages. Techniques such as **type analysis**

[^1]: The compiler can "predict" the type of the receiver based on the message name and insert a runtime check before the message. It usually allows for later inlining based on the most frequent type. The type can be propagated through the control flow graph and can use type casing with several branches corresponding to the possible types and their version of the inlined method. 

, **customization**

[^2]: Extends dynamic compilation by exploiting the fact that many messages within a method are sent to `self`. The compiler creates a separate compiled version of a given source method for each receiver type. This duplication allows for customization. In particular, knowing the type of `self` at compile time allows all `self` sends to be inlined without any type tests. Customization can also be applied to global variable, instance variable for example.

, and **splitting** 

[^3]: Turns a polymorphic message into several separate monomorphic messages and avoids tests by copying parts of the control flow graph.

 have been shown to be very effective in reducing this disparity.

A new acceleration approach is presented: ***Polymorphic Inline Caches (PICs)*** that provide both an improvement of the efficiency of message sends and valuable type information that can be reused to conduct by the compiler to produce other optimizations.

Smalltalk code is dynamically compiled and machine code is cached. Method lookup is responsible for a substantial part of the execution time. **Lookup caches** reduce the overhead by mapping (Receiver types - Message name) pairs to methods and holding to the most recently used result. **Inline caches** use the fact that the type of the receiver at a given call site rarely varies and caches the looked-up method address at the call site, overwriting the call instruction.

Polymorphic sends have to be handled differently because using a simple inline cache would result in a permanent overwriting of the method address (due to the changing type) and therefore an additional call to the expensive lookup method. 

Sends are either:

- ***Monomorphic:*** one receiver type (1)
- ***Polymorphic:*** a few receiver types (2-10)
- ***Megamorphic:*** a lot of receiver types (10+)

A ***PIC*** will cache ALL lookup results for a given polymorphic call-site in a specially-generated stub routine that looks like the following after few calls of the method on different receiver types:

```pseudocode
if type = type1:						   |  Check receiver type
	jump to method     ___________________ | _______________________
										   | Code to apply on type 1
										   
if type = type2:                           | Check receiver type
	jump to method     ___________________ | _______________________
										   | Code to apply on type 2
	
call lookup            ___________________ | Fallback: call expensive lookup
```

A ***PIC*** is therefore an *extensible cache with no cache in which no cache item is ever displaced by another (newer) item*.

Remaining problems and possible solutions:

- **Megamorphic sends handling:** The inline cache miss handler should not extend the ***PIC*** beyond a certain number of type cases. It should mark the call-site as megamorphic and adopt a fallback strategy.
- **Linear search improvement:** If the dynamic usage frequency of each type were available, ***PICs*** could be reordered periodically to move the most frequently occurring types on top.
- **Short methods inlining:** Many methods are very small (*e.g*. output one of the receiver's instance variable). Such methods could be integrated into the ***PIC*** directly rather than being called by it.
- **Space efficiency improvement:** If the system runs on tight space, call sites with identical message names could share a common ***PIC*** to reduce the space overhead.},
 doi = {10.1007/bfb0057013},
 groups = {VM, Read},
 journal = {ECCOP Proceedings},
 pages = {21-38},
 title = {Optimizing dynamically-typed object-oriented languages with polymorphic inline caches},
 year = {1991}
}

@article{Hoelzle1992,
 author = {Urs HÃ¶lzle and Craig Chambers and David Ungar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/143095.143114},
 groups = {VM},
 journal = {ACM},
 pages = {32-43},
 title = {Debugging optimized code with dynamic deoptimization},
 year = {1992}
}

@article{Hoelzle1994,
 author = {Urs HÃ¶lzle and David Ungar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/191081.191116},
 groups = {VM},
 issn = {0362-1340},
 journal = {OOPSLA},
 pages = {229-243},
 title = {A third-generation SELF implementation: reconciling responsiveness with performance},
 volume = {29},
 year = {1994}
}

@phdthesis{Hoelzle1994a,
 author = {Urs HÃ¶lzle},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 groups = {VM},
 title = {Adaptive Optimization for Self: Reconciling High Performance with Exploratory Programming},
 type = {phdthesis},
 year = {1994}
}

@article{Humer2015,
 author = {Christian Humer and Christian Wimmer and Christian Wirth and Andreas WÃ¶ÃŸ and Thomas WÃ¼rthinger},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2775053.2658776},
 groups = {VM, Read},
 issn = {0362-1340},
 journal = {GPCE},
 pages = {123-132},
 title = {A domain-specific language for building self-optimizing AST interpreters},
 volume = {50},
 year = {2015}
}

@article{Hussein2015,
 author = {Ahmed Hussein and Antony L. Hosking and Mathias Payer and Christopher A. Vick},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2754169.2754182},
 groups = {VM},
 journal = {ISMM},
 title = {Don't race the memory bus: taming the GC leadfoot},
 year = {2015}
}

@article{Hussein2015a,
 author = {Ahmed Hussein and Mathias Payer and Antony Hosking and Christopher A. Vick},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2757667.2757674},
 groups = {VM},
 journal = {SYSTOR},
 title = {Impact of GC design on power and performance for Android},
 year = {2015}
}

@article{Ierusalimschy2005,
 author = {Ierusalimschy, Roberto and De Figueiredo, Luiz Henrique and Celes Filho, Waldemar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

[22/04/2021]

Main objectives of Lua: *simplicity* (simple language for simple C code), efficiency (fast one-pass compiler and VM), *portability* (clean ANSI C implementation), *embeddability* (simple C API), *low embedding cost* (small Lua core and extension as user libraries).

Hand-written compiler (YACC too slow) with scanner and recursive descent parser. No intermediate representation, instructions for the VM emitted on the fly. Fastest language implementation of interpreted and dynamically-typed languages. 

**Values representation:** Eight basic types (*nil, boolean, number, string, table, function, userdata, thread*). Tables are associative arrays with index. Userdata consists of pointers to memory blocks (*heavy* allocated by Lua and GCd or *light* allocated and freed by the user). Values of **all types are first class values**, they can be stored in globals, locals and table fields, passed as arguments etc. Value types are stored as a C union:

```c
typedef union {
	GCObject *gc; // strings tables etc.
	void p*;      // light userdata
	lua_Number n; // double
	int b;        // integer
} Value;
```

This solution is expensive to copy values but ensures portability. Strings are immutable and internalized in a hash table



**Tables:** The only data structures in Lua are tables, or **associative arrays**. They can be indexed by any value and hold values of any type. They are dynamic because they grow or shrink accordingly. Only one set of operators is needed to perform operations on tables or arrays. Tables are implemented as **hybrid data structures** (**array part** with implicit integer index and **hash part** with other indexes). The load factor is balanced by testing both parts and choosing an n such as at least half the slots between 1 and n are used and that at least one is used between n/2+1 and n. The hash part uses a mix of  *chained scatter table with Brent's variation*.

**Functions and Closures:** **Upvalues** are used to implement closures. Any outer local variable is accessed indirectly through an upvalue. **The upvalue originally points to the stack slot wherein the variable lives. When it goes out of scope, the value migrates into a slot in the upvalue itself**. The migration is transparent to all the users. To ensure the uniqueness, a linked list of all open upvalues is kept. When a new closure is created, all outer local variables are gone through and if an open value is found, it uses this one, otherwise it creates and links it. **Flat closures** allows to pour outer variables into inner closures.

**Threads and Coroutines:** Asymmetric coroutines are supported by the functions `create`, `resume` and `yield`. Each coroutine has its own stack and are stackful (it can be suspended from inside any number of nested calls). Combination of stackfulness and first-class status makes coroutines equivalent to one-shot continuations.

**The VM itself:** For each function that Lua compiles it creates a prototype which contains an array with the opcodes for the function and an array of Lua values with all constants used by the function. Register-based VM allows for less instructions and a single fetch time because operands are inside the instruction. Instructions are 32 bits long divided into three or four fields: OP|A|B|C or OP|A|Bx or OP|A|sBx where A is the destination, B and C registers, Bx an unsigned value and sBx a signed value. Branch instructions are decoupled in a test and a jump instruction. If the test is not verified, the next instruction is skipped. Each function (and coroutine) holds two stacks, the activation records of the other functions and a large array of temporary values corresponding to a given function.



},
 journal = {J. UCS},
 number = {7},
 pages = {1159--1176},
 title = {The Implementation of Lua 5.0.},
 volume = {11},
 year = {2005}
}

@article{Ingalls1997,
 author = {Dan Ingalls and Ted Kaehler and John Maloney and Scott Wallace and Alan Kay},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/263698.263754},
 groups = {VM},
 journal = {OOPSLA},
 title = {Back to the future: the story of Squeak, a practical Smalltalk written in itself},
 year = {1997}
}

@inproceedings{Jain2014,
 author = {Bhushan Jain and Mirza Basim Baig and Dongli Zhang and Donald E. Porter and Radu Sion},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/sp/JainBZPS14.bib},
 booktitle = {2014 {IEEE} Symposium on Security and Privacy, {SP} 2014, Berkeley, CA, USA, May 18-21, 2014},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

[27/04/2021]

The goals of **Virtual Machine Introspection (VMI)** is to identify if the guest OS has been compromised, if malicious applications are running on the system or if sensitive file have uncompromised secrecy or integrity. A *semantic gap* occurs when using a hypervisor to look into VM behavior as the abstractions used by the hypervisor policies are higher-level than what he can actually see (registers and cpu state). Most of VMI development goes into reconstructing high-level semantic from low-level sources.

To close this semantic gap, the **reconstruction** of data models is essential. A **learning phase** is used to extract information related to data structures (**signature**). A **search phase** can then look for instances of this data structure. Signatures are either handcrafted (`memparser`, `kntlist`  or `grepexec`), extracted from source analysis (`siggraph`, `kop` or `mas`)  and dynamic learning by studying a trusted OS behavior.

Other methods allow to bridge the gap , such as *code implanting* where the objective is to inject code into the guest OS that reports information back to the hypervisor, *process outgrafting*  that relocates the monitoring process from an untrusted VM to a second, trusted one or *kernel executable integrity* enforces the fact that the executable of the kernel has not been modified. This can be enforced by:  1) the W+X principle where a memory page can either be *writable* or *executable* but not both at the same time, 2) *whitelisting portions of code*.

- Current VMI systems face fundamental trade-offs between performance and risk, often making fragile assumptions about the guest OS

  },
 doi = {10.1109/SP.2014.45},
 pages = {605--620},
 publisher = {{IEEE} Computer Society},
 title = {SoK: Introspections on Trust and the Semantic Gap},
 year = {2014}
}

@inproceedings{Jain2014,
 author = {Jain, Bhushan and Baig, Mirza Basim and Zhang, Dongli and Porter, Donald E. and Sion, Radu},
 booktitle = {2014 IEEE Symposium on Security and Privacy},
 doi = {10.1109/SP.2014.45},
 number = {},
 pages = {605-620},
 title = {SoK: Introspections on Trust and the Semantic Gap},
 volume = {},
 year = {2014}
}

@inproceedings{Kermarrec2019,
 author = {Kermarrec, Florent and Bourdeauducq, S{\'e}bastien and Badier, Hannah and Le Lann, Jean-Christophe},
 booktitle = {OSDA 2019, colocated with DATE 2019 Design Automation and Test in Europe},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 title = {LiteX: an Open-Source SoC builder and library based on Migen Python DSL},
 year = {2019}
}

@article{Kermarrec2020,
 archiveprefix = {arXiv},
 author = {Florent Kermarrec and SÃ©bastien Bourdeauducq and Jean-Christophe Le Lann and Hannah Badier},
 eprint = {2005.02506},
 file = {:http\://arxiv.org/pdf/2005.02506v1:PDF},
 keywords = {cs.AR},
 month = {may},
 primaryclass = {cs.AR},
 title = {LiteX: an open-source SoC builder and library based on Migen Python DSL},
 year = {2020}
}

@article{Kocher2018,
 abstract = {Modern processors use branch prediction and speculative execution to maximize performance. For example, if the destination of a branch depends on a memory value that is in the process of being read, CPUs will try guess the destination and attempt to execute ahead. When the memory value finally arrives, the CPU either discards or commits the speculative computation. Speculative logic is unfaithful in how it executes, can access to the victim's memory and registers, and can perform operations with measurable side effects. Spectre attacks involve inducing a victim to speculatively perform operations that would not occur during correct program execution and which leak the victim's confidential information via a side channel to the adversary. This paper describes practical attacks that combine methodology from side channel attacks, fault attacks, and return-oriented programming that can read arbitrary memory from the victim's process. More broadly, the paper shows that speculative execution implementations violate the security assumptions underpinning numerous software security mechanisms, including operating system process separation, static analysis, containerization, just-in-time (JIT) compilation, and countermeasures to cache timing/side-channel attacks. These attacks represent a serious threat to actual systems, since vulnerable speculative execution capabilities are found in microprocessors from Intel, AMD, and ARM that are used in billions of devices. While makeshift processor-specific countermeasures are possible in some cases, sound solutions will require fixes to processor designs as well as updates to instruction set architectures (ISAs) to give hardware architects and software developers a common understanding as to what computation state CPU implementations are (and are not) permitted to leak.},
 archiveprefix = {arXiv},
 author = {Paul Kocher and Daniel Genkin and Daniel Gruss and Werner Haas and Mike Hamburg and Moritz Lipp and Stefan Mangard and Thomas Prescher and Michael Schwarz and Yuval Yarom},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[13/01/2021]*

A central security feature of operating systems is **memory isolation**. It ensures programs cannot access each other's or kernel's memory. It allows running multiple operations at the same time. This isolation is usually performed by a **supervisor bit** of the processor that defines whether a memory page of the kernel can be accessed or not . This bit can only be set when entering kernel code and is cleared when switching to user processes. This hardware feature **allows operating system to map the kernel into the address space of every process** and have efficient transitions from user processes to the kernel.},
 eprint = {1801.01203},
 file = {:http\://arxiv.org/pdf/1801.01203v1:PDF},
 keywords = {cs.CR},
 month = {jan},
 primaryclass = {cs.CR},
 title = {Spectre Attacks: Exploiting Speculative Execution},
 year = {2018}
}

@inproceedings{Kotselidis2017,
 address = {New York, NY, USA},
 author = {Kotselidis, Christos and Nisbet, Andy and Zakkak, Foivos S. and Foutris, Nikos},
 booktitle = {Proceedings of the 9th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/3141871.3141872},
 isbn = {9781450355193},
 keywords = {cross-isa, debug, just-in-time compilation, metacircular, maxine vm, qemu},
 location = {Vancouver, BC, Canada},
 numpages = {9},
 pages = {1â€“9},
 publisher = {Association for Computing Machinery},
 series = {VMIL 2017},
 title = {Cross-ISA Debugging in Meta-Circular VMs},
 url = {https://doi.org/10.1145/3141871.3141872},
 year = {2017}
}

@article{Kotzmann2008,
 author = {Thomas Kotzmann and Christian Wimmer and Hanspeter MÃ¶ssenbÃ¶ck and Thomas Rodriguez and Kenneth Russell and David Cox},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1369396.1370017},
 groups = {VM},
 issn = {1544-3566},
 journal = {ACO},
 pages = {1-32},
 title = {Design of the Java HotSpotâ„¢ client compiler for Java 6},
 volume = {5},
 year = {2008}
}

@misc{Krasner1983,
 author = {Glenn {Krasner}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 editor = {Glenn {Krasner}},
 howpublished = {{Addison-Wesley Series in Computer Science. Reading, Massachusetts, etc.: Addison-Wesley Publishing Company. VIII, 344 p. (1983).}},
 keywords = {68-02 68N99},
 language = {English},
 title = {Smalltalk-80. Bits of history, words of advice},
 year = {1983},
 zbl = {0537.68008}
}

@article{Kulkarni2013,
 author = {S. Kulkarni and J. Cavazos and C. Wimmer and D. Simon},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/cgo.2013.6495004},
 groups = {VM},
 journal = {CGO},
 title = {Automatic construction of inlining heuristics using machine learning},
 year = {2013}
}

@misc{Lee2006,
 author = {Keunwoo Lee and Craig Chambers},
 doi = {10.1007/11785477_21},
 issn = {0302-9743},
 pages = {353-378},
 title = {Parameterized Modules for Classes and Extensible Functions},
 year = {2006}
}

@inproceedings{Leroy2006,
 address = {New York, NY, USA},
 author = {Leroy, Xavier},
 booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1111037.1111042},
 isbn = {1595930272},
 keywords = {the Coq theorem prover, program proof, certified compilation, semantic preservation, compiler transformations and optimizations},
 location = {Charleston, South Carolina, USA},
 numpages = {13},
 pages = {42â€“54},
 publisher = {Association for Computing Machinery},
 series = {POPL '06},
 title = {Formal Certification of a Compiler Back-End or: Programming a Compiler with a Proof Assistant},
 url = {https://doi.org/10.1145/1111037.1111042},
 year = {2006}
}

@article{Lima2020a,
 archiveprefix = {arXiv},
 author = {Igor Lima and Jefferson Silva and Breno Miranda and Gustavo Pinto and Marcelo d'Amorim},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 eprint = {2012.03759},
 file = {:http\://arxiv.org/pdf/2012.03759v1:PDF},
 groups = {VM, Testing},
 journal = {Software Quality Journal 2021},
 keywords = {cs.SE},
 primaryclass = {cs.SE},
 title = {Exposing Bugs in JavaScript Engines through Test Transplantation and Differential Testing},
 year = {2020}
}

@inproceedings{Lin2014,
 author = {Rongheng Lin and Budan Wu and Sen Su and Peng Xu and Shasha Yang and Yao Zhao},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/IEEEcloud/LinWSXYZ14.bib},
 booktitle = {2014 {IEEE} 7th International Conference on Cloud Computing, Anchorage, AK, USA, June 27 - July 2, 2014},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/CLOUD.2014.142},
 pages = {960--961},
 publisher = {{IEEE} Computer Society},
 title = {A Security PaaS Container with a Customized {JVM}},
 year = {2014}
}

@inproceedings{Lin2016,
 author = {Yi Lin and Stephen M. Blackburn and Antony L. Hosking and Michael Norrish},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/iwmm/LinBHN16.bib},
 booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} International Symposium on Memory Management, Santa Barbara, CA, USA, June 14 - 14, 2016},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2926697.2926707},
 editor = {Christine H. Flood and Eddy Zheng Zhang},
 pages = {89--98},
 publisher = {{ACM}},
 title = {Rust as a language for high performance {GC} implementation},
 year = {2016}
}

@inproceedings{Lipp2018,
 author = {Moritz Lipp and Michael Schwarz and Daniel Gruss and Thomas Prescher and Werner Haas and Anders Fogh and Jann Horn and Stefan Mangard and Paul Kocher and Daniel Genkin and Yuval Yarom and Mike Hamburg},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/uss/Lipp0G0HFHMKGYH18.bib},
 booktitle = {27th {USENIX} Security Symposium, {USENIX} Security 2018, Baltimore, MD, USA, August 15-17, 2018},
 editor = {William Enck and Adrienne Porter Felt},
 pages = {973--990},
 publisher = {{USENIX} Association},
 title = {Meltdown: Reading Kernel Memory from User Space},
 url = {https://www.usenix.org/conference/usenixsecurity18/presentation/lipp},
 year = {2018}
}

@unpublished{Marr2017,
 address = {Pleinlaan 2, B-1050 Brussels, Belgium},
 author = {Stefan Marr},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 note = {ISBN 9789057182563},
 publisher = {VUBPress},
 school = {Software Languages Lab, Vrije Universiteit Brussel},
 title = {Supporting Concurrency Abstractions in High-level Language Virtual Machines},
 url = {https://kar.kent.ac.uk/63836/},
 year = {2017}
}

@inproceedings{Paleczny2001,
 author = {Michael Paleczny and Christopher A. Vick and Cliff Click},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/jvm/PalecznyVC01.bib},
 booktitle = {Proceedings of the 1st Java Virtual Machine Research and Technology Symposium, April 23-24, 2001, Monterey, CA, {USA}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 editor = {Saul Wold},
 groups = {VM},
 publisher = {{USENIX}},
 title = {The Java HotSpot Server Compiler},
 url = {http://www.usenix.org/publications/library/proceedings/jvm01/paleczny.html},
 year = {2001}
}

@inproceedings{Patel2019,
 author = {Mrunal Patel and Shenghsun Cho and Michael Ferdman and Peter A. Milder},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/fpl/PatelCFM19.bib},
 booktitle = {29th International Conference on Field Programmable Logic and Applications, {FPL} 2019, Barcelona, Spain, September 8-12, 2019},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/FPL.2019.00018},
 editor = {Ioannis Sourdis and Christos{-}Savvas Bouganis and Carlos {\'{A}}lvarez and Leonel Antonio Toledo D{\'{\i}}az and Pedro Valero{-}Lara and Xavier Martorell},
 pages = {51--58},
 publisher = {{IEEE}},
 title = {Runtime-Programmable Pipelines for Model Checkers on FPGAs},
 year = {2019}
}

@inproceedings{Pedersen2017,
 author = {Mathias V. Pedersen and Aslan Askarov},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/sp/PedersenA17.bib},
 booktitle = {2017 {IEEE} Symposium on Security and Privacy, {SP} 2017, San Jose, CA, USA, May 22-26, 2017},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/SP.2017.64},
 pages = {693--709},
 publisher = {{IEEE} Computer Society},
 title = {From Trash to Treasure: Timing-Sensitive Garbage Collection},
 year = {2017}
}

@article{Piumarta1998,
 author = {Ian Piumarta and Fabio Riccardi},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/277652.277743},
 groups = {VM},
 issn = {0362-1340},
 journal = {SIGPLAN},
 pages = {291-300},
 title = {Optimizing direct threaded code by selective inlining},
 volume = {33},
 year = {1998}
}

@misc{Piumarta2008,
 author = {Ian Piumarta and Alessandro Warth},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1007/978-3-540-89275-5_1},
 issn = {0302-9743},
 pages = {1-30},
 title = {Open, Extensible Object Models},
 year = {2008}
}

@article{Popek1974,
 author = {Gerald J. Popek and Robert P. Goldberg},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/361011.361073},
 groups = {VM},
 issn = {0001-0782},
 journal = {OSP},
 pages = {412-421},
 title = {Formal requirements for virtualizable third generation architectures},
 volume = {17},
 year = {1974}
}

@inproceedings{Reynolds2010,
 author = {Mark C. Reynolds},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/asm/Reynolds10.bib},
 booktitle = {Abstract State Machines, Alloy, {B} and Z, Second International Conference, {ABZ} 2010, Orford, QC, Canada, February 22-25, 2010. Proceedings},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[02/02/2021]*

Java Security is enforced in three ways:

- The **Java** **compiler** has a large number of **rules** that it enforces in order to ensure that the **syntax and semantics of the Java language are satisfied** but also to prohibit actions that are known to be malicious (e.g. uninitialized variables).
- The **Java** **class loader**, is used to port a classfile into the Java execution environment. When class loading is performed, the **Java Bytecode Verifier** is used to assert the bytecode are of correct form and types.
- The **Java Runtime** performs array bounds checking, type conversion checkings, etc. 



Almost all Java exploits use weaknesses in the **Bytecode Verifier**. The verifier uses a constraints-based approach to perform its analysis. The objective is to (1) provide an extensible framework for modeling security constraints and (2) provide a concrete model for meaningful, high value security constraints.},
 doi = {10.1007/978-3-642-11811-1\_12},
 editor = {Marc Frappier and Uwe Gl{\"{a}}sser and Sarfraz Khurshid and R{\'{e}}gine Laleau and Steve Reeves},
 pages = {146--159},
 publisher = {Springer},
 series = {Lecture Notes in Computer Science},
 title = {Lightweight Modeling of Java Virtual Machine Security Constraints},
 url = {https://doi.org/10.1007/978-3-642-11811-1_12},
 volume = {5977},
 year = {2010}
}

@inproceedings{Rigo2006,
 author = {Armin Rigo and Samuele Pedroni},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/oopsla/RigoP06.bib},
 booktitle = {Companion to the 21th Annual {ACM} {SIGPLAN} Conference on Object-Oriented Programming, Systems, Languages, and Applications, {OOPSLA} 2006, October 22-26, 2006, Portland, Oregon, {USA}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1176617.1176753},
 editor = {Peri L. Tarr and William R. Cook},
 groups = {VM, Read},
 pages = {944--953},
 publisher = {{ACM}},
 title = {PyPy's approach to virtual machine construction},
 year = {2006}
}

@inproceedings{Rizzo2010,
 author = {Juliano Rizzo and Thai Duong},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/woot/RizzoD10.bib},
 booktitle = {4th {USENIX} Workshop on Offensive Technologies, {WOOT} '10, Washington, D.C., USA, August 9, 2010},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10/practical},
 editor = {Charlie Miller and Hovav Shacham},
 publisher = {{USENIX} Association},
 title = {Practical Padding Oracle Attacks},
 year = {2010}
}

@article{Rohou2012,
 author = {Erven Rohou},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/icppw.2012.58},
 groups = {VM},
 journal = {41st International Conference on Parallel Processing Workshops.},
 title = {Tiptop: Hardware Performance Counters for the Masses},
 year = {2012}
}

@article{Rohou2015,
 author = {Erven Rohou and Bharath Narasimha Swamy and Andre Seznec},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/cgo.2015.7054191},
 groups = {VM},
 journal = {CGO},
 title = {Branch prediction and the performance of interpreters, Don't trust folklore},
 year = {2015}
}

@inproceedings{Russell2006,
 author = {Kenneth Russell and David Detlefs},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/oopsla/RussellD06.bib},
 booktitle = {Proceedings of the 21th Annual {ACM} {SIGPLAN} Conference on Object-Oriented Programming, Systems, Languages, and Applications, {OOPSLA} 2006, October 22-26, 2006, Portland, Oregon, {USA}},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1167473.1167496},
 editor = {Peri L. Tarr and William R. Cook},
 groups = {VM},
 pages = {263--272},
 publisher = {{ACM}},
 title = {Eliminating synchronization-related atomic operations with biased locking and bulk rebiasing},
 year = {2006}
}

@article{Sachindran2004,
 author = {Narendran Sachindran and J. Eliot B. Moss and Emery D. Berger},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1028976.1028984},
 groups = {VM},
 journal = {OOPSLA},
 title = {MC2: high-performance garbage collection for memory-constrained environments},
 year = {2004}
}

@article{Samples1986,
 author = {A. Dain Samples and David Ungar and Paul Hilfinger},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/28697.28708},
 groups = {VM},
 journal = {ACM},
 title = {SOAR: Smalltalk without bytecodes},
 year = {1986}
}

@inproceedings{Schrammel2020,
 author = {David Schrammel and Samuel Weiser and Stefan Steinegger and Martin Schwarzl and Michael Schwarz and Stefan Mangard and Daniel Gruss},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/uss/SchrammelWSS0MG20.bib},
 booktitle = {29th {USENIX} Security Symposium, {USENIX} Security 2020, August 12-14, 2020},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

[22/04/2021]

Need for memory isolation to secure any system. This can be applied to any layer of the software stack (e.g. process isolation, separate address spaces, etc.). Donky consists of a **hardware-software co-design providing strong in-process isolation guarantees based on memory protection keys**. It also offers **pure userspace policy management with negligible overhead and full backward-compatibility**.

RISC-V comprises the unprivileged ISA and privileged ISA. Control and Status Registers (CSR) allows configuring the CPU , access performance metrics and additional exception handling. They are prefixed with `m` (machine), `s` (supervisor) or `u` (user). To handle exceptions,  the CPU switches to machine mode and jumps to the address specified in the trap-vector base-address register (`mtvec`). RISC-V specifies a "Standard Extension for User-Level Interrupts" as **N extension**.

Modern CPUs support virtual address spaces for process isolation. For virtual-to-physical translation, address spaces are mapped in blocks of pages (4KiB). Their entries are cached in the translation-lookaside buffer (TLB). Page-table entries (PTE) help manage permissions per page such that the same physical page can be mapped in multiple virtual address spaces. Kernel level switches are required to update permissions, switch address space, etc.  An extension to page-based memory is enabled with memory protection keys. PTE are tagged with a protection key but the permissions are stored separately. Keys are associated with a protection domain and each memory region can have one associated key. Example: Intel MPK, ARM Memory Domains, IBM Power, etc.

JavaScript is **jitted** and sandboxed through browsers to enforce security. The source code is dynamically first compiled into an intermediate representation which is then interpreted and executed. Another component analyses the runtime and further optimizes the bytecode directly into machine code. This requires the code region to be both writable and executable. In V8, an ***Isolate*** is an independent copy of the entire JavaScript runtime environment (*code cache, gc and call stack*). As sandbox escapes are still possible, an additional security uses process isolation.

**Software design:** the Donky Monitor is the **trusted handler in charge of managing in-process access policies and securing domains from each other**. Any operation on domains or protection keys will invoke the Donky Monitor. Domain switches guarded with `dcalls`, tampering guarded with memory encapsulation in a separate domain, security enforced by a hardware call-gate mechanism that enforces the entry point. The Donky API expands the **POSIX** interface. It allows to manage domains, protection keys and associated memory, and share keys with other domains.

**Hardware design:** Memory protection keys are configured in the PTE of a process (upmost 10 bits). The userspace register (`DKRU`) can load **4 different protection keys simultaneously**. Each loaded key **enables the read/write of the corresponding PTE**. Additionally, each slot has a specific bit to enforce read-only mode. The monitor bit (upmost of `DKRU`) can be cleared to prevent unauthorized alteration of the protection key policy. A new exception is raised when a security violation is detected while the monitor bit in `DKRU` is cleared. The MMU is extended to verify that for any data access the protection key in the PTE matches at least one loaded in `DKRU`.

**Security Evaluation:** *Hardware call gates* prevent code-reuse attacks on Donky Monitor. *System calls and signals* are interposed by Donky by redirecting them to the Monitor. The *Donky Monitor* itself validates all inputs in the *Donky API*.

},
 editor = {Srdjan Capkun and Franziska Roesner},
 pages = {1677--1694},
 publisher = {{USENIX} Association},
 title = {Donky: Domain Keys - Efficient In-Process Isolation for {RISC-V} and x86},
 url = {https://www.usenix.org/conference/usenixsecurity20/presentation/schrammel},
 year = {2020}
}

@inproceedings{Schwarz2019,
 abstract = {In early 2018, Meltdown first showed how to read arbitrary kernel memory from user space by exploiting side-effects from transient instructions. While this attack has been mitigated through stronger isolation boundaries between user and kernel space, Meltdown inspired an entirely new class of fault-driven transient-execution attacks. Particularly, over the past year, Meltdown-type attacks have been extended to not only leak data from the L1 cache but also from various other microarchitectural structures, including the FPU register file and store buffer.In this paper, we present the ZombieLoad attack which uncovers a novel Meltdown-type effect in the processor's fill-buffer logic. Our analysis shows that faulting load instructions (i.e., loads that have to be re-issued) may transiently dereference unauthorized destinations previously brought into the fill buffer by the current or a sibling logical CPU. In contrast to concurrent attacks on the fill buffer, we are the first to report data leakage of recently loaded and stored stale values across logical cores even on Meltdown- and MDS-resistant processors. Hence, despite Intel's claims, we show that the hardware fixes in new CPUs are not sufficient. We demonstrate ZombieLoad's effectiveness in a multitude of practical attack scenarios across CPU privilege rings, OS processes, virtual machines, and SGX enclaves. We discuss both short and long-term mitigation approaches and arrive at the conclusion that disabling hyperthreading is the only possible workaround to prevent at least the most-powerful cross-hyperthread attack scenarios on current processors, as Intel's software fixes are incomplete.},
 address = {New York, NY, USA},
 author = {Schwarz, Michael and Lipp, Moritz and Moghimi, Daniel and Van Bulck, Jo and Stecklina, Julian and Prescher, Thomas and Gruss, Daniel},
 booktitle = {Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/3319535.3354252},
 isbn = {9781450367479},
 keywords = {side-channel attack, meltdown, transient execution, fill buffer},
 location = {London, United Kingdom},
 numpages = {16},
 pages = {753â€“768},
 publisher = {Association for Computing Machinery},
 series = {CCS '19},
 title = {ZombieLoad: Cross-Privilege-Boundary Data Sampling},
 url = {https://doi.org/10.1145/3319535.3354252},
 year = {2019}
}

@article{Seaton2014,
 author = {Chris Seaton and Michael L. Van De Vanter and Michael Haupt},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2617548.2617550},
 groups = {VM},
 journal = {DYLA},
 title = {Debugging at Full Speed},
 year = {2014}
}

@article{Shaylor2003,
 author = {Nik Shaylor and Douglas N. Simon and William R. Bush},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

**The size of Java classfiles** has long been recognized as an issue, especially for embedded devices. Several methods exist to reduce the size, both as a transmission format and as an execution format. Some methods try to perturb the Java execution engine as little as possible while the **Java Card Paradigm introduces a muscular transformer between classfiles and interpreter.**

The projectâ€™s main goal of building a CLDC-compliant system on a small device led to a few straightforward consequent goals, namely *minimizing the size of transmitted classfiles*, the *RAM needed for classfile loading*, the *size of loaded classfiles*, the *RAM required during execution*, and the *size of the interpreter and memory system*.

These goals are then translated in design choices:

- Standard CLDC classfiles are too large and complex. Using a **Java Card** technique, they are **preprocessed off-device** and packaged in a smaller representation (*suite*) that can be verified and loaded on-device.
- The **classfile preprocesor** identifies code snippets that are hard to verify or garbage collect and translates them into simpler versions
- Standard classfiles contain symbolic information for resolving references. **References are now resolved before execution**, either during off-device translation or during the installation of suites on the device.
- Standard construction and **object initialization is recasted** into an equivalent form that can be verified more efficiently
- Three memory spaces are available with different characteristics. A **region-aware memory manager** is therefore used.



Bytecode verification and exact garbage collection are complex on small devices, especially due to the fact that pointers are hard to find and track. While CLDC added a classfile attribute called a *stackmap*, it is too complex and memory intensive. Specific restrictions are added to the translator and applied when the conversion from classfiles to *suites* is performed:

- **A local variable can only hold one type**
- **The evaluation stack must be empty at the end of a basic block**
- **Bytecodes that can trigger a GC may only be executed when the evaluation stack contains only the operands for those bytecodes**



A compact bytecode set is used with **reduced operand field sizes** that can then be extended (8 bits by default but that can be extended to 12, 16 or 32). Local variables are explicitly typed so **no type-specific load and store are needed**. Symbolic references (through a name string rather than an index or pointer) are **resolved as much as possible** when they are written into the memory of the target device **during loading**. A **field access** can be resolved to an **absolute offset within an object**, a **method invocation** to an **offset in a vtable**. Simple two-pass verification process. First step reads the bytecode and verifies **type safety**, **class member references** and writes them in NVM. Second pass checks the **branch targets** are valid.

Standard Java object construction creates an *uninitialized* object and then fills it up. Squawk does not expose uninitialized object references to the bytecode. The **object method constructor creates the object and returns the address of the newly created object**. A *null* flag is used as the first parameter. A constructor will allocate an object and replace the first parameter only if that parameter is *null*.



**Memory:**

- Three memory spaces: *RAM*, *NVM* and *ROM*. Objects in less permanent memory are allowed to contain references to objets in more permanent memory but not the other way around.
- *Chunky stack* composed of chunks allocated in the *RAM heap*. Each chunk is a Java object and can be GC'd.
- Class definition information is divided into *immutable* and *mutable*. All objects have a one-word header pointing to the immutable class information for that object.
- *Object monitors* are used to implement synchronization. The monitors are placed in an LRU queue in RAM. All monitors keep a reference to their corresponding objects.

**Implementation:**

- *Methods* are *byte arrays*
- Every class contains a *reference to a byte array that contains an object pointer map* used by the GC
- A class state record is the mutable part of a class definition, it contains the object reference fields and the integer fields used to hold the static variables of the class. The class state records are kept in an LRU queue in the RAM.

Garbage collection is performed when the `interpret` method fails and outputs an `OutOfMemory` error. The `gc()` method is only called when it fails to allocate a stack chunk, when it fails to allocate an object or when it is explicitly called:

```java
for (;;) {
	interpret(result);
	result = gc();
}
```



},
 doi = {10.1145/780732.780738},
 groups = {VM, Read},
 journal = {LCTES},
 title = {A java virtual machine architecture for very small devices},
 year = {2003}
}

@article{Siefers2010,
 author = {Joseph Siefers and Gang Tan and Greg Morrisett},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/ccs/SiefersTM10.bib},
 booktitle = {Proceedings of the 17th {ACM} Conference on Computer and Communications Security, {CCS} 2010, Chicago, Illinois, USA, October 4-8, 2010},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[26/01/2021]*

Security for native code in Java applications. Based on **software-based fault isolation (SFI)**, Robusta isolates native code into a sandbox where **dynamic linking/loading of libraries** is supported and **unsafe system modification and confidentiality violations are prevented**.

The introduction of native functions in Java applications is done with the use of the **Java Native Interface (JNI)** along with the keyword `native`. Native code resides in the **same address space** as Java code but is not constrained by the **Java Security Model**. Native code can therefore **read/write any memory location** or cause **integrity and confidentiality violations** (e.g. *type-confusion attacks*).

Robusta defends with **SFI to isolate untrusted native code from the rest of the JVM** (done with Google's NaCl). Next, all JNI calls are redirected to **JNI trampolines** using "fake" interface pointers to untrusted native code. Those trampolines are the *only* way native code can escape the sandbox. They invoke trusted JNI wrappers outside of the sandbox to perform some safety checks. Robusta also prevents the JNI from using direct pointers to Java primitive arrays and native code from calling Java methods. Finally, Robusta connects to Java's Security Manager to mediate native system calls.

JVM **integrity** is ensured by the following definition: *Suppose one execution step in native code brings a state (s, h, w) (JVM stack, JVM heap, native world) to (s', h', w'). The integrity is respected if s is equal to s' and h is included in h'*. JVM **confidentiality** is respected if native code accesses **only objects reachable by the references set by the JVM** and if the **access-control modifiers** (e.g. `private`) **of fields and methods are respected**. Next, the system calls have to follow given policies.

Native code isolation:

- **Google's Native Client (NaCl)** and the use of **trampolines** (from untrusted to trusted) and **springboards** (reverse).
- **Secure Dynamic Linking/Loading:** the address space is separated into a code space (cs) and a data space (ds) and an address is interpreted differently whether it is used as a code or a data address. The usage of a dynamic library is guarded by a specific routine. 

**NaCl JVM integration:** When the JVM starts, Robusta constructs an NaCl sandbox, reserves a memory region for the NaCl address space and sets up a code and a data region. Page protection is configured so that the **code region is readable and executable** while the **data region is readable and writable**. **Trusted trampolines** are installed in the code region. Finally the dynamic linker/loader is loaded into the NaCl address space.

**Sandbox of JNI calls:** Native methods access JNI through an interface pointer. This pointer usually goes through the JNI methods however they are here outside of the sandbox. Robusta duplicates the function table with pointers to JNI trampolines so that the native function can access the outside of the sandbox if authorized. The JNI checks includes several safety checks (type, signature, etc.). JNI allows efficient access to primitive arrays however direct access to the heap is dangerous to provide to native functions. Robusta performs a copy-in/copy-out.

**Native Code Security:** The regulation of native system calls goes through the Java's Security Manager. It accepts or denies a system call based on a security policy. A security policy can grant two kinds of permissions: **mode permissions** and **system-access permissions**. **Mode permissions** specify whether a library can be loaded into the JVM and whether it should be sandboxed. The mode policy is enforced during library-loading. **System-access permissions** define what an application is allowed to perform (e.g. read or write files).

},
 doi = {10.1145/1866307.1866331},
 editor = {Ehab Al{-}Shaer and Angelos D. Keromytis and Vitaly Shmatikov},
 pages = {201--211},
 publisher = {{ACM}},
 title = {Robusta: taming the native beast of the {JVM}},
 year = {2010}
}

@article{Simon2015,
 author = {Doug Simon and Christian Wimmer and Bernhard Urban and Gilles Duboscq and Lukas Stadler and Thomas WÃ¼rthinger},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2764907},
 groups = {VM},
 issn = {1544-3566},
 journal = {ACM},
 title = {Snippets: Taking the High Road to a Low Level},
 volume = {12},
 year = {2015}
}

@book{Smith2005,
 author = {James E. Smith and Ravi Nair},
 doi = {10.1016/b978-155860910-5/50009-4},
 groups = {VM},
 pages = {369-443},
 title = {System Virtual Machines},
 year = {2005}
}

@inproceedings{Stadler2014,
 author = {Lukas Stadler and Thomas W{\"{u}}rthinger and Hanspeter M{\"{o}}ssenb{\"{o}}ck},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/cgo/StadlerWM14.bib},
 booktitle = {12th Annual {IEEE/ACM} International Symposium on Code Generation and Optimization, {CGO} 2014, Orlando, FL, USA, February 15-19, 2014},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 editor = {David R. Kaeli and Tipp Moseley},
 groups = {VM},
 pages = {165},
 publisher = {{ACM}},
 title = {Partial Escape Analysis and Scalar Replacement for Java},
 url = {https://dl.acm.org/citation.cfm?id=2544157},
 year = {2014}
}

@article{Ungar1984,
 author = {David Ungar and Ricki Blau and Peter Foley and Dain Samples and David Patterson},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/773453.808182},
 groups = {VM},
 issn = {0163-5964},
 journal = {IEEE},
 pages = {188-197},
 title = {Architecture of SOAR: Smalltalk on a RISC},
 volume = {12},
 year = {1984}
}

@article{Ungar1984a,
 author = {David Ungar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/390010.808261},
 groups = {VM},
 issn = {0163-5948},
 journal = {IEEE},
 pages = {157-167},
 title = {Generation Scavenging: A non-disruptive high performance storage reclamation algorithm},
 volume = {9},
 year = {1984}
}

@article{Ungar1987,
 author = {David Ungar and Randall B. Smith},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/38765.38828},
 groups = {VM},
 journal = {ACM},
 title = {Self: The power of simplicity},
 year = {1987}
}

@article{Ungar1987b,
 author = {David M. Ungar and David A. Patterson},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/journals/computer/UngarP87.bib},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1109/MC.1987.1663359},
 groups = {VM},
 journal = {Computer},
 number = {1},
 pages = {67--74},
 title = {What Price Smalltalk?},
 volume = {20},
 year = {1987}
}

@phdthesis{Ungar1987c,
 author = {David Ungar},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1016/0141-9331(87)90466-2},
 groups = {VM},
 issn = {0141-9331},
 journal = {ACM},
 pages = {562},
 title = {The design and evaluation of a high performance Smalltalk system},
 volume = {11},
 year = {1987}
}

@article{Ungar2005,
 author = {David Ungar and Adam Spitz and Alex Ausch},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/1094855.1094865},
 groups = {VM},
 journal = {OOPSLA},
 title = {Constructing a metacircular Virtual machine in an exploratory programming environment},
 year = {2005}
}

@article{Vanter2015,
 author = {Michael L. Van De Vanter},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2843915.2843917},
 groups = {VM},
 journal = {ICOOOLPS},
 title = {Building debuggers and other tools: we can "have it all"},
 year = {2015}
}

@phdthesis{Varoumas2019,
 author = {Steven Varoumas},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/phd/hal/Varoumas19.bib},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 groups = {VM},
 school = {Sorbonne University, Paris, France},
 title = {Mod{\`{e}}les de programmation de haut niveau pour microcontr{\^{o}}leurs {\`{a}} faibles ressources. (High-level programming models for microcontrollers with scarce resources)},
 url = {https://tel.archives-ouvertes.fr/tel-02426454},
 year = {2019}
}

@article{Wimmer2013,
 author = {Christian Wimmer and Michael Haupt and Michael L. Van De Vanter and Mick Jordan and Laurent DaynÃ¨s and Douglas Simon},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2400682.2400689},
 groups = {VM},
 issn = {1544-3566},
 journal = {ACO},
 pages = {1-24},
 title = {Maxine: An approachable virtual machine for, and in Java},
 volume = {9},
 year = {2013}
}

@article{Woess2014,
 author = {Andreas WÃ¶ÃŸ and Christian Wirth and Daniele Bonetta and Chris Seaton and Christian Humer and Hanspeter MÃ¶ssenbÃ¶ck},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2647508.2647517},
 groups = {VM},
 journal = {PPPJ},
 title = {An object storage model for the truffle language implementation framework},
 year = {2014}
}

@inproceedings{wolczko1996self,
 author = {Wolczko, Mario},
 booktitle = {Workshop on Prototype-Based Languages, ECOOP â€˜96, Linz, Austria},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 groups = {VM},
 title = {self includes: Smalltalk},
 year = {1996}
}

@inproceedings{Wu2018,
 address = {Boston, MA},
 author = {Xiaofeng Wu and Kun Suo and Yong Zhao and Jia Rao},
 booktitle = {10th {USENIX} Workshop on Hot Topics in Cloud Computing (HotCloud 18)},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[13/01/2021]*

**CPU time-multiplexing** is a common practice in multitenant systems to improve system utilization. However, the sharing of CPU and a single system clock makes it difficult for programs to accurately measure the length of an operation. **Applications employing time-based resource management face a potential security threat of time manipulation** (through dilation). 

HotSpot (JVM) relies on timing **garbage-collections to infer a heap size**. A side-channel attack exploits time dilation to break the heap sizing algorithm and causes any program to raise an out-of-memory error. It can be configured with an initial `-Xms` and maximal `-Xmx` heap size. during runtime, the JVM adjusts the size based on statistics from GC. In general, the heap is **shrunk** if each individual GC takes too long and **violates a user-defined pause-time target**. It is also **expanded** if GC is frequently performed and the total GC time constitutes a significant portion of the total execution time (**violates throughput target**). If **both targets** are met, the JVM **gradually shrinks the heap to save memory**. Most Java heap sizing algorithm use measured GC time, which is based on **wall-clock time**.

**Adaptive-sizing in Parallel-Scavenge (PS):** Stop-the-world throughput-oriented algorithm that uses multiple GC threads to scan the heap and is expected to meet two goals, **pause-time** and **throughput** that are both user-defined. PS divides the heap into multiple generations: *young, old* and *metaspace*. The *young* space is divided into one *eden* and two survivor spaces, the *from-space* and the *to-space*. New objects are put in the *eden* which, once filled, will perform a minor GC where referenced objects from the *eden* and *from-space* are moved to the *to-space*. The *eden* and *from-space* are then cleared and object in the *to-space* get their age increased. After surviving several generations, the objects in the *to-space* are moved in the *old* generation. 

**An Out-of-Memory (OOM)** error occurs when the JVM does not have space to allocate a new object in the heap. The PS algorithm tries to allocate an object in 5 tries before raising the error: (1) minor GC on young generation, (2) major GC in old and move mature objects from young to old, (3) allocate directly in the old generation, (4) major GC with soft references in the young generation and (5) another try to allocate directly in the old generation.

The GC cost is a metric used in adaptive heap sizing. The cost of a particular GC (major or minor) corresponds to the *time of the GC* / *(time since last GC + time of the GC)*. Note that it might include the time spent in another GC. All time measurement are based on wall-clock time (`gettimeofday`). Several adjustment mechanisms exist for each of the different spaces and given a main goal (pause-time or throughput).

**Time Dilation in Multi-tenant Systems:** The *Time-stamp Counter* is commonly used for timekeeping as it is an **auto-incremented register on CPU at the clock rate**. Timing utilities such as `gettimeofday` use this register to keep track of time. Leaving the control of time keeping utilities to an external tool can allow other programs to run between the meantime and dilate the time spent performing an action.

},
 month = {jul},
 publisher = {{USENIX} Association},
 title = {A Side-channel Attack on HotSpot Heap Management},
 url = {https://www.usenix.org/conference/hotcloud18/presentation/wu},
 year = {2018}
}

@article{Wuerthinger2012,
 author = {Thomas WÃ¼rthinger and Andreas WÃ¶ÃŸ and Lukas Stadler and Gilles Duboscq and Doug Simon and Christian Wimmer},
 doi = {10.1145/2384577.2384587},
 groups = {VM},
 journal = {DLS},
 title = {Self-optimizing AST interpreters},
 year = {2012}
}

@inproceedings{Wuerthinger2013,
 author = {Thomas W{\"{u}}rthinger and Christian Wimmer and Andreas W{\"{o}}{\ss} and Lukas Stadler and Gilles Duboscq and Christian Humer and Gregor Richards and Doug Simon and Mario Wolczko},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/conf/oopsla/WurthingerWWSDHRSW13.bib},
 booktitle = {{ACM} Symposium on New Ideas in Programming and Reflections on Software, Onward! 2013, part of {SPLASH} '13, Indianapolis, IN, USA, October 26-31, 2013},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1145/2509578.2509581},
 editor = {Antony L. Hosking and Patrick Th. Eugster and Robert Hirschfeld},
 groups = {VM},
 pages = {187--204},
 publisher = {{ACM}},
 title = {One {VM} to rule them all},
 year = {2013}
}

@misc{Yoshihiko1999,
 author = {Futamura Yoshihiko},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->},
 doi = {10.1.1.10.2747},
 groups = {VM},
 journal = {SYSTEMS COMPUTERS CONTROLS},
 title = {Partial Evaluation of Computation Process: an Approach to a Compiler-compiler},
 year = {1999}
}

@article{Zandberg2020,
 archiveprefix = {arXiv},
 author = {Koen Zandberg and Emmanuel Baccelli},
 bibsource = {dblp computer science bibliography, https://dblp.org},
 biburl = {https://dblp.org/rec/journals/corr/abs-2011-12047.bib},
 comment = {<!-- Please prefix the notes with the date as in [22/12/2020] -->

*[15/12/2020]*

Enhancing the security of low-power low-memory devices can take the form of **process isolation**. This isolation can be conducted either:

	- By isolating **high-level business** logic, updatable on-demand remotely over the low-power network *(long-lived, non-real-time timing requirements)*
	- By isolating **debug/monitoring** code snippets at low-level, inserted and removed on-demand, remotely over the network *(short-lived, strict timing requirements)*

Concretely performing the isolation can be performed through a *modification of the hardware architecture* to add mechanisms to guarantee process isolation. This is the path taken by the **TrustZone on Arm Cortex-M**, **Sanctum on RISC-V** or **Sancus2.0 on MSP430**.

On the other hand, software-only equivalent can be achieved to perform process isolation:

-  **Small VMs:** *Darjeeling*, a subset of the JVM using a 16-bit architectures. *Wasm*, a VM specification designed for process isolation in web browsers. *JavaCard*, a small JVM running on smart cards. *eBPF* small VM hosting and isolating debug and inspection code in the Linux kernel at runtime.
- **Scripted Logic Interpreters:** *Small JavaScript run-time container* hosting business logic interpreted aboard a microcontroller, glued atop a real-time OS (*RIOT*).
- **OS-Level Mechanisms:** *Tock* is an OS written in Rust that offers strong isolation between its kernel and application logic processes. However it requires a memory protection unit (MPU).



Comparison of two VMs:

- **WebAssembly (Wasm):** Stack-based VM that uses a heap and memory allocations in chunks of 64KiB (pages). Wasm uses the LLVM compiler and once  binary is created, it is transferred to the IoT device on which it is interpreted and executed. Several interpreters exist and WASM3, for example, transpiles the loaded application to an optimized executable that can then be executed in the interpreter.
- **Extended Berkeley Packet Filters (eBPF):** Small in-kernel VM available on Unix-like OS. Original purpose was packet filtering but got rebranded to other purposes. 64-bit register-based VM with a fixed 512B stack. No heap is presented in the specification but an interface to key-value maps is used as an alternative for persistent storage between invocations.



Design of **rBPF**, a variant of the eBPF VM designed to be ISA-compatible. It extends the bindings to be able to access the OS facilities and events. The VM is integrated in the **RIOT OS** and scheduled as a regular thread. The VM can interact with multiple OS event sources. Tehe VM is based on an iterative loop design over the application instructions. Depending on the instruction, **different protection mechanisms are activated**. (1) Host address space isolated from the sandbox by policies loaded in the VM. (2) Protections on the code executed ensure the VM does not start executing code outside the supplied application. Note that the eBPF ISA *does not support indirect jump instructions and no pc register is available*. This means the virtual program counter can only be modified via the guarded direct branch and jump instructions.



VM adds overhead that has an impact on execution time and a measurable additional size. While the Wasm VM requires too much RAM and ROM, rBPF looks like a good compromise between security through process isolation and memory and time overhead.},
 eprint = {2011.12047},
 groups = {VM, Hardware, Security, Read},
 journal = {CoRR},
 title = {Minimal Virtual Machines on IoT Microcontrollers: The Case of Berkeley Packet Filters with rBPF},
 url = {https://arxiv.org/abs/2011.12047},
 volume = {abs/2011.12047},
 year = {2020}
}

